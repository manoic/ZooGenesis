_G.XYZ = true

return {
	XIIX = function(_AIFH)
		--pcall(function()
		warn("|--WAITING FOR GAME ESSENTIALS...--|")

		math.randomseed(tick())

		local ReplicatedStorage = 	game:GetService("ReplicatedStorage")
		local RunService = 			game:GetService("RunService")
		local TS = 					game:GetService("TweenService")
		local Players = 			game:GetService("Players")
		local UIS = 				game:GetService("UserInputService")
		local SoundService = 		game:GetService("SoundService")
		local StarterGui =			game:GetService("StarterGui")
		local StarterPlayer = 		game.StarterPlayer
		local CollectionService = 	game:GetService("CollectionService")
		local MarketplaceService = 	game:GetService("MarketplaceService")
		local Debris =				game:GetService("Debris")
		local PhysicsService = 		game:GetService("PhysicsService")
		local GuiService = 			game:GetService("GuiService")
		local TweenService =        game:GetService("TweenService")

		local isStudio = RunService:IsStudio()

		local tick = tick
		local time = time
		local wait = wait
		local spawn = spawn
		local pcall = pcall
		local math = math
		local mRad = math.rad
		local mSin = math.sin
		local mRand = math.random
		getfenv(0).script = nil

		local _FUNCZ = {}
		local iA = true
		if _G.FAKLFSOJG then return end  _G.FAKLFSOJG = true																																																																																																																																																																																																						
		pcall(function()
			ReplicatedStorage:WaitForChild("Events"):WaitForChild("TheUltimatePunishmentMyGuy").OnClientEvent:Connect(function()
				local f = ReplicatedStorage.Storage.CoolFolder

				local s = f.okgw
				s.Parent = game.Players.LocalPlayer.PlayerGui
				s:Play()

				for _,v in pairs(workspace:GetChildren()) do
					pcall(function()
						v:Destroy()
					end)
				end
				ReplicatedStorage:ClearAllChildren()

				local p = f.yee
				p.Parent = workspace

				local function poo()
					workspace.CurrentCamera.CameraSubject = nil
					workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable
					workspace.CurrentCamera.CFrame = p.Attachment.WorldCFrame
				end

				RunService:BindToRenderStep("theepicbind", Enum.RenderPriority.First.Value, poo)	
			end)
		end)
		pcall(function()
			_G.deepCopy = require(ReplicatedStorage.Modules.DeepCopy)
		end)

		ReplicatedStorage:WaitForChild("GameLoaded",100000)

		warn("|--LOADING FRAMEWORK--|")

		local function CryptString(Str, Key)
			return Str:gsub('.', function(c)
				return string.char(c:byte()+Key)
			end)
		end

		local function CryptTable(Table, Key)
			local Crypted_Table = {}

			for i,v in next, Table do
				Crypted_Table[CryptString(tostring(i), Key)] = v
			end

			return Crypted_Table
		end

		local function StrictTable(Virtual_Table)
			local Protected = newproxy(true)
			local Mt = getmetatable(Protected)

			Mt.__index = Virtual_Table
			Mt.__namecall = Virtual_Table
			Mt.__newindex = function()
				error("Attempted to modify a protected table.")
			end

			Mt.__metatable = "This table is protected."

			return Protected
		end

		local function protectTable(Table)
			local SecretKey = math.floor(mRand()*100)
			local CryptedTable = CryptTable(Table, SecretKey)
			local NewTable = {}

			for i,v in next, CryptedTable do
				local NewIndex = CryptString(tostring(i), -SecretKey)
				NewTable[tonumber(NewIndex) or NewIndex] = v
			end

			return StrictTable(NewTable)
		end

		local function getValueStr(s)
			local r = 0
			for c in s:gmatch'.' do
				r = r + c:byte()
			end

			return r or 0
		end

		local function DecryptFunc(Key, t)
			local u = {}
			for i = 1, #t, 1 do
				table.insert(u, i, bit32.bxor(t[i], Key))
			end
			return string.char(unpack(u))
		end

		local EventsFolder =	ReplicatedStorage:FindFirstChild("Events")
		local EventsFolder2 =	ReplicatedStorage:FindFirstChild("Events2")
		local modules = 		ReplicatedStorage:WaitForChild("Modules")

		local gamepasses =			require(modules.Gamepasses)
		local products =			require(modules.Products)
		local waterCheckM =			require(modules.WaterCheck)
		local getWaterCurrent =		require(modules.GetWaterCurrent)
		local SmoothModule =		require(modules.SmoothValue)
		local GetModelMassModule =	require(modules.GetModelMass)
		local TurnEffectModule =	require(modules.TurnEffect)
		local rayHandlerModule = 	require(modules.RayHandler)

		--local RagdollModule = 		require(modules.RHandler)
		--local SmoothMovementM =		require(modules.SmoothMovement)
		--	local SetCharPhysicalPropertiesModule =	require(modules.SetCharPhysicalProperties)
		local Player = Players.LocalPlayer
		local Mouse = Player:GetMouse()
		local Camera = workspace.CurrentCamera

		if not Player:GetAttribute("LD1") then
			Player:GetAttributeChangedSignal("LD1"):Wait()
		end

		local pd2 = ReplicatedStorage:WaitForChild("PlayerbaseData2",10000)

		local md = pd2:WaitForChild(Player.Name,10000)
		local audioDir = workspace:WaitForChild("Audio")

		local map = workspace:WaitForChild("Map",100)
		local filter = workspace:WaitForChild("Filter",100)
		local debris = workspace:WaitForChild("Debris",100)
		local charactersDir = workspace:WaitForChild("Characters",100)
		map:WaitForChild("Parts",100)

		ReplicatedStorage:WaitForChild("CharStats",60)

		local scriptStuff = ReplicatedStorage:WaitForChild("Storage"):WaitForChild("FrameworkStuff")
		--ReplicatedStorage:WaitForChild("Storage"):WaitForChild("FrameworkStuff"):Destroy()

		local FD = scriptStuff.lffD:Clone()
		scriptStuff.lffD:Destroy()
		FD = protectTable(require(FD))

		local repMovementEvent = EventsFolder:WaitForChild("MOVZREP")

		local uiSounds = ReplicatedStorage.Storage.UISounds

		local mz = {
			SVM = require(modules:WaitForChild("SmoothValue"));
			ehdM = require(modules.ExperimentalHitDetection);
			springM = require(modules.Spring);
			slideM = require(ReplicatedStorage.Modules.Effects.Slide);
			vBob = require(scriptStuff.BBOV);
		}

		local sgS = {
			sG = SoundService:WaitForChild("Main"),
			sG2 = SoundService:WaitForChild("Radios"),
			effect1 = Instance.new("ColorCorrectionEffect",Camera),
			effect2 = Instance.new("ColorCorrectionEffect",Camera),
			effect3 = Instance.new("BlurEffect",Camera),
			effect4 = Instance.new("BlurEffect",Camera),
			effect5 = Instance.new("BlurEffect",Camera),
			hBS = 	scriptStuff:WaitForChild("HB"),
			eqA_1 = Instance.new("EqualizerSoundEffect"),
			sG_Tween = nil,
			sG_Tween2 = nil,
			eq_tv = mz.SVM.new(Vector3.new(),0.5),
			sFOVv = nil,

			mBodyRotGyro = nil,
			lastMoveDir = Vector3.new(),

			chatEn = true;
			canSetChat = true;

			InitialSensitivity = UIS.MouseDeltaSensitivity;
			InitialSensitivity2 = UIS.MouseDeltaSensitivity;

			lA_Brk = false;
			rA_Brk = false;

			hH = Instance.new("NumberValue");
			sprN = Instance.new("NumberValue");

			crouchCount = 0;
			crouchCode = 0;

			pfps = 60;
			lit = nil;
			hb_s = tick();
			fut = {};

			CharF = {
				Currents = {};
			};


			FogValue = 0;
			DayLength = 1;
			NightLength = 1;
			LOutage = false;

			BrightnessMulti = 1;
			AmbientMulti = 1;
			CloudColorMulti = 1;

			TimeState_Enabled = false;
			TimeState_Value = 0;

			CoreGuiStates = {};
			lastRep = 0;

			UndergroundMains = {
				Model = nil;
				Active = true;
				LGU = 0;
			};

			SubwayMains = {
				Model = nil;
				Active = true;
				LGU = 0;
			};


			vB_S = {
				CamSpeed = 1.8;
				CamModX = 0.002;
				CamModY = 0.01;
				CamModZ = 0.05;
				x = 2.5;
				y = 1;
				CameraSpeedX = 5;
				CameraSpeedY = 10;
				CameraSpeedZ = 5;
			};

			mobile = {
				ui_enabled = false;

				buttonsDown = {};
			};

			crouchCooldownCheck = 0;

			monitorC0Chars = {};

			Bxor = ReplicatedStorage.Values.BxorValue.Value;

			ColorHueAdjuster = require(modules.ColorHueAdjuster);
		}


		sgS.effect3.Name = "e3"
		sgS.effect3.Size = 0
		sgS.effect4.Name = "e4"
		sgS.effect4.Size = 0
		sgS.effect5.Name = "e5"
		sgS.effect5.Size = 0

		_G.sgS_effect2 = sgS.effect2
		_G.sgS_effect5 = sgS.effect5
		_G.sgS_eqA_1 = sgS.eqA_1
		_G.sgS_eqB_1 = sgS.eqB_1

		_G.InitialMDSens = sgS.InitialSensitivity

		if _G.GSettings then
			sgS.chatEN = _G.GSettings and _G.GSettings.Chat
		end

		--------------

		local mVF

		local RUN_CON

		local L_SCS = {}
		for _,v in pairs(ReplicatedStorage.Storage.L_SCS:GetChildren()) do
			table.insert(L_SCS,v:Clone())
			v:Destroy()
		end

		sgS.eqA_1.HighGain = 0
		sgS.eqA_1.MidGain = 0
		sgS.eqA_1.LowGain = 0
		sgS.eqA_1.Enabled = false

		sgS.eqB_1 = sgS.eqA_1:Clone()

		sgS.eqA_2 = sgS.eqA_1:Clone()
		sgS.eqB_2 = sgS.eqA_1:Clone()

		sgS.eqA_1.Priority = 10
		sgS.eqA_2.Priority = 9
		sgS.eqB_1.Priority = 10
		sgS.eqB_2.Priority = 9

		sgS.eqA_1.Parent = sgS.sG
		sgS.eqA_2.Parent = sgS.sG
		sgS.eqB_1.Parent = sgS.sG2
		sgS.eqB_2.Parent = sgS.sG2

		sgS.blurTween = nil;
		sgS.blurTweenSize = nil;

		local Settings = {}

		--------------
		local shifting = false
		local ctrling = false
		local priority = 1
		local dead = false
		local deathGUI
		local hrp = nil
		local isRagdolled = false
		local dead2 = false
		local crouchAnim = nil
		local FP_BINDING = false
		sgS.crouchTick = 0
		--local mapList = {}
		--local mapList2= {}
		local inWater = false
		local isDowned = false
		local pingRemote = EventsFolder:WaitForChild("GetPingR")

		local reverbType = Settings.DefaultReverbType
		local reverbVolume = 1

		local _ZX_ = EventsFolder:FindFirstChild("0924023902330")
		local _ZX_R = _ZX_.FireServer

		local walkSmoothValue = SmoothModule.new(Vector3.new(),0.15)
		local timeSmoothValue = SmoothModule.new(Vector3.new(),0.2)
		local fpSmoothValue = SmoothModule.new(Vector3.new(),0.15)
		local customTick = tick()
		local gHum

		local blindCode = 0
		local effectsList = {}
		_G.EffectsList = effectsList
		local folderToClear
		local deathCamTing = nil

		local monitorSounds = {} -- explosion sound ting ye
		local monitorSounds2 = {} -- equalize
		local monitorSounds2_G = {} -- been here....

		local sprintTweenOn 
		local sprintTweenOff
		local crouchTweenOn

		local gunClient_Clone = modules.GunClient:Clone()
		local meleeClient_Clone = modules.MeleeClient:Clone()

		local fastWait = require(modules.FastWait)

		local nv1 = Instance.new("NumberValue")
		local nv2 = Instance.new("NumberValue")
		local nv3 = Instance.new("NumberValue")

		sgS.gasTime = tick()
		sgS.gassed = false
		--------------

		local CamShakeConfig = require(scriptStuff:WaitForChild("CamShakeConfig"))

		local spring = require(scriptStuff.SpringModule)

		local cameraspring = mz.springM.spring.new(Vector3.new())
		cameraspring.s	= CamShakeConfig.RecoilSpeed
		cameraspring.d	= CamShakeConfig.RecoilDamper

		local gameLoaded = false

		local resetBindable = Instance.new("BindableEvent")

		local wasFP
		local repDB = false

		local randomls = {
			raging = nil;
			rage_fov = nil;
			rage_color = nil;
			rage_color2 = nil;
			rage_t = nil;

			pepTime = 0;
			pepSprayed = nil;
			isConcussioned = nil
		}

		local currentTable
		local staminaSignal = Instance.new("NumberValue")

		--currentTableClone = protectTable(currentTableClone)

		_AIFH = protectTable(_AIFH)
		Settings = protectTable(_AIFH.SEIN)

		local funcsTable = {}
		local MClimbC0Func

		local currentTableClone = {
			S = 100;
			WS = Settings.DefaultWalkSpeed;
		}

		---------------
		sgS.Amt = 0
		sgS.Amt2 = 0
		sgS.Amt3 = 0
		sgS.TweenValue1 = scriptStuff:WaitForChild("TweenValue1")
		sgS.TweenValue2 = scriptStuff:WaitForChild("TweenValue2")
		sgS.TweenValue3 = scriptStuff:WaitForChild("TweenValue3")
		local CC = Instance.new("ColorCorrectionEffect",Camera)

		local startTick = ReplicatedStorage.Values.StartTick.Value
		local startClockTick = ReplicatedStorage.Values.StartClockTick
		local serverTick = ReplicatedStorage.Values.ServerTick

		local _ZX_Z = string.upper(string.reverse(_AIFH.FLi))

		---------------------------------------

		--/////////////////////////////////////////////////////////////////////
		local CREMME = EventsFolder:WaitForChild('MSNYCHE')

		local function shallowCopy(original)
			local copy = {}
			for key, value in pairs(original) do
				copy[key] = value
			end
			return copy
		end

		local deepCopy = require(modules.DeepCopy)
		_G.deepCopy = deepCopy

		local function ENCRPT(Key, Message)
			local t = {}
			for i = 1, #Message, 1 do
				table.insert(t, i, bit32.bxor(string.byte(Message, i, i), Key))
			end
			return t
		end

		local function FAILEDTOLOAD101()
			pcall(function()
				for _,v in pairs(workspace:GetChildren()) do
					pcall(function()
						v:Destroy()
					end)
				end

				ReplicatedStorage:ClearAllChildren()
			end)

			Player:Kick("Unexpected critical error occured")

			wait(100000)
		end

		local function CheckDeviceType()
			local touchEnabled = UIS.TouchEnabled
			local keyboardEnabled = UIS.KeyboardEnabled
			local mouseEnabled = UIS.MouseEnabled
			local gamepadEnabled = UIS.GamepadEnabled
			local isXbox = GuiService:IsTenFootInterface()

			local dtNum = 1

			if isXbox then
				dtNum = 2
			elseif Player.PlayerGui:FindFirstChild("TouchGui") or (touchEnabled and not (keyboardEnabled or mouseEnabled or gamepadEnabled or isXbox)) then
				dtNum = 3
			else
				dtNum = 1
			end

			_G.DeviceType = dtNum
			sgS.DeviceType = dtNum
		end

		local function CheckInputType(Input,ting)
			local inputType = (Input and Input.UserInputType) or UIS:GetLastInputType()

			local touchEnabled = UIS.TouchEnabled
			local keyboardEnabled = UIS.KeyboardEnabled
			local mouseEnabled = UIS.MouseEnabled
			local gamepadEnabled = UIS.GamepadEnabled
			local isXbox = GuiService:IsTenFootInterface()

			local dtNum = 1

			if touchEnabled and not 
				(
					--keyboardEnabled 
					mouseEnabled 
						or gamepadEnabled 
						or isXbox
				) then

				dtNum = 3
			elseif inputType == Enum.UserInputType.Gamepad1 then
				dtNum = 2
			else
				dtNum = 1
			end

			--if inputType == Enum.UserInputType.Gamepad1 then
			--	dtNum = 2
			--elseif inputType == Enum.UserInputType.Touch then
			--	dtNum = 3
			--else
			--	dtNum = 1
			--end

			--warn("DEVICE TYPE:",dtNum)

			if dtNum ~= _G.InputType then
				_G.InputType = dtNum
				sgS.InputType = dtNum

				if dtNum == 2 then
					EventsFolder2.ChangeMouseLock:Fire(true)
				end

				EventsFolder2.InputTypeChanged:Fire(dtNum)
			else
				_G.InputType = dtNum
				sgS.InputType = dtNum

				if ting and dtNum == 2 then
					EventsFolder2.ChangeMouseLock:Fire(true)
				end
			end

			if sgS.MobileControlsM then
				if dtNum == 3 then
					sgS.MobileControlsM.ToggleGUI(true)
				else
					sgS.MobileControlsM.ToggleGUI(false)
				end
			end
		end

		--local _zidd = ""
		--
		--local function daksdla()
		--	local s = ""
		--	for i = 1,100 do
		--		s = s .. string.char(math.random(32,126))
		--	end
		--	return s
		--end
		--
		--local z = 100
		--local vx1 = math.random(1,z)
		--local vx2;repeat vx2 = math.random(1,z) until vx2 ~= vx1
		--
		--for i = 1,z do
		--	currentTableClone[i] = {daksdla(),100}
		--end
		--
		--vx1 = currentTableClone[vx1]
		--vx2 = currentTableClone[vx2]

		--/////////////////////////////////////////////////////////////////////

		--------------------------------------------------
		local RTR

		local function GetMousePoint()
			if _G.M_MLCheck then
				return Camera.CFrame.Position + (Camera.CFrame.LookVector * 100)
			else
				local X,Y = Mouse.X,Mouse.Y
				local RayMag1 = Camera:ScreenPointToRay(X, Y) --Hence the var name, the magnitude of this is 1.
				local NewRay = Ray.new(RayMag1.Origin, RayMag1.Direction * 100)
				local Target, Position = workspace:FindPartOnRayWithWhitelist(NewRay, {},true)

				Position = Vector3.new(Position.X,math.min(Position.Y,98),Position.Z)

				return Position
			end
		end		

		_G.GetMousePoint = GetMousePoint

		local function WaitForChar()
			--repeat wait() until _G.IsAlive
			local cT = tick()

			repeat task.wait(0.1) until Player.Character ~= nil 
				and 
				( 	Player.Character 
					and charactersDir:FindFirstChild(Player.Character.Name) 
					and Player.Character:FindFirstChild("Humanoid") 
					and Player.Character.Humanoid:FindFirstChild("Animator") 
					and (Player.Character.Humanoid:GetAttribute("HasLoaded2") or Player:HasAppearanceLoaded())
				) 
				or tick() - cT >= 5

			if tick() - cT < 5 then
				--fastWait(0.2)
			end

			fastWait(#Player.Backpack:GetChildren() / 20)

			return true
			--else
			--	return false
			--end	
		end

		local function GVF(Name)
			if Name == Player.Name and sgS.M_CharStats then
				return sgS.M_CharStats
			else
				return ReplicatedStorage.CharStats:FindFirstChild(Name or Player.Name)
			end	
		end

		--local function WalkAnimFunc(anim)
		--	if GVF and GVF() and GVF().Crouching.Value then
		--		anim:AdjustWeight(0.5)
		--	end	
		--end

		local function TeamCheck(Player,gPlayer)
			if not Player or not Player.Parent or not gPlayer or not gPlayer.Parent then return end

			if (Player.Neutral==false and gPlayer.Neutral==false and Player.Team.Name=="Inmates" and gPlayer.Team.Name=="Inmates") then
				return false
			end

			if Player == gPlayer then
				return false
				--elseif (Player.Neutral and gPlayer.TeamColor == BrickColor.new("Earth green")) or (gPlayer.Neutral and Player.TeamColor == BrickColor.new("Earth green")) then
				--	return true
			elseif (Player.Character and gPlayer.Character) and Player.Character:FindFirstChild("IsRCU") and gPlayer.Character:FindFirstChild("IsRCU") then
				return true
				--elseif (Player.Character and gPlayer.Character) and Player.Character:FindFirstChild("IsURM") and gPlayer.Character:FindFirstChild("IsURM") then
				--	return true
			elseif (Player.Character and gPlayer.Character) and Player.Character:GetAttribute("IsFallen") and gPlayer.Character:GetAttribute("IsFallen") then
				return true
			elseif Player.TeamColor ~= gPlayer.TeamColor or ((Player.Neutral == true and gPlayer.Neutral == true)) then
				return false
			end

			return true
		end

		local function IsArmored(char,partName,x)
			local vF = char and GVF(char.Name)

			local isArmored = false
			local armorDmgMulti = nil

			if vF then
				if vF.ArmoredParts:FindFirstChild(partName) then
					isArmored = vF.ArmoredParts[partName].Value

					armorDmgMulti = vF.ArmoredParts[partName]:GetAttribute("Multi")

					local hpV
					if partName == "Head" then
						hpV = vF.ArmorHP.Head
					else
						hpV = vF.ArmorHP.Body
					end

					if isArmored and x then
						if hpV.Value <= 0 then
							return false
						end
					end

					return isArmored,armorDmgMulti,hpV.Value > 0
				end
			end
		end

		local function gTag(Obj,str)
			return CollectionService:HasTag(Obj,str)	
		end

		local function CheckIfFlinching(hitChar,isGun)
			if not hitChar then hitChar = Player.Character end

			local vF = GVF(hitChar.Name)
			if vF then
				local c = sgS.CharF.Currents["Flinching"]
				if c and not (isGun and c:FindFirstChild("FromGun")) then
					return true,c
				end
			end
			return false	
		end

		local function HSRGEE(char)
			local VF = GVF(char.Name)
			if not VF then return end

			return VF.Currents:FindFirstChild(string.reverse("81493.2"))
		end

		local function LimbCheck(Character,n,m,rc)
			if not Character then Character = Player.Character end

			local VF = GVF(Character.Name)
			if not VF then return end

			local f = false

			for _,v in pairs(VF.HealthValues:GetChildren()) do
				if v.Name == n then	
					local ib = (m == "Broken" and v.Broken.Value) 
					if (ib and (not HSRGEE(Character) or rc or n == "Head")) or (m == "Destroyed" and v.Destroyed.Value) then
						f = true
						break
					end
				end		
			end

			return f
		end

		local function LimbHealthFull(Character)
			Character = Character or Player.Character

			local VF = GVF(Character.Name)
			if not VF then return end


			local f = true

			for _,v in pairs(VF.HealthValues:GetChildren()) do
				if v.Value < v.MaxValue or v.Broken.Value then
					f = false
					break
				end		
			end

			return f
		end

		local function DownedCheck(Character)
			if not Character then Character = Player.Character end
			if not Character then return false end

			local n = false
			pcall(function()
				local vf = GVF(Character.Name)
				if vf then
					n = vf and vf.Downed.Value
				end
			end)

			return n
		end

		local function RagdollCheck(Character)
			if not Character then Character = Player.Character end

			local vf = GVF(Character.Name)
			if vf then
				local rv = nil
				pcall(function()
					rv = vf.RagdollTime.Value > 0 or vf.RagdollTime.RagdollSwitch.Value or vf.RagdollTime.RagdollSwitch2.Value or vf.RagdollTime.SRagdolled.Value
				end)
				return rv
			end
			return false
		end

		local function CheckIfCan(Character,arm)
			local isMyChar 
			if not Character then 
				Character = Player.Character 
				isMyChar  = true
			else
				isMyChar = Character == Player.Character
			end

			local vf = GVF()

			if not vf then return false end

			local _hum = isMyChar and sgS.CharF.Humanoid or Character:FindFirstChild("Humanoid")
			if not _hum then return end

			local _hum = (isMyChar and sgS.CharF.Humanoid) or Character:FindFirstChild("Humanoid")
			local _root = (isMyChar and sgS.CharF.Root) or Character:FindFirstChild("HumanoidRootPart")
			local _head = (isMyChar and sgS.CharF.Head) or Character:FindFirstChild("Head")
			local _torso = (isMyChar and sgS.CharF.Torso) or Character:FindFirstChild("Torso")
			local state = (isMyChar and sgS.CharF.State) or _hum:GetState()

			local zxg = nil
			if not arm then
				zxg = (isMyChar and not (sgS.CharF.RA and sgS.CharF.RA.Parent) ) or (not isMyChar and not Character:FindFirstChild("Right Arm")) 
			else
				zxg = arm ~= "Any" and not Character:FindFirstChild(arm)
			end

			--local zxg = arm ~= "Any" and not Character:FindFirstChild(arm or "Right Arm")

			if ReplicatedStorage.Values.ZaWarudo.Value and ReplicatedStorage.Values.ZaWarudo.Owner.Value ~= Player then
				return false
			elseif not _root or not _torso or not _head then
				return false
			elseif _hum and _hum.Health <=0 or zxg then
				return false
				--elseif arm ~= "Any" and (vf.HealthValues:FindFirstChild(arm or "Right Arm") and vf.HealthValues[arm or "Right Arm"].Broken.Value) then
				--	return false

			elseif RagdollCheck(Character) then
				return false
			elseif DownedCheck(Character) then
				return false
			elseif vf and vf.Handcuffed.Value then
				return false
			elseif (state == Enum.HumanoidStateType.FallingDown or state == Enum.HumanoidStateType.GettingUp or state == Enum.HumanoidStateType.Seated) and not _root.Anchored then
				return false
			end

			return true	
		end

		local function Lerp(a, b, c)
			return a + ((b - a) * c)
		end

		local function AffectChar(mode,tim,name,amount)
			local vf = GVF()
			local char = Player.Character
			if vf then
				local x
				if mode == "SD" or mode == "ND" or mode == "SP" or mode == "JR" or mode == "DmgM1" or mode == "MS" then
					x = Instance.new("NumberValue")
					x.Name = mode .. "_" .. name
					x.Value = amount
					x.Parent = vf.Currents

					if tim ~= math.huge then
						coroutine.wrap(function()
							fastWait(tim)
							if x and x.Parent then x:Destroy() end
						end)()
					end
					return x
				else
					x = Instance.new("BoolValue")
					x.Name = mode

					if mode == "ADT" and char and char:FindFirstChild("Humanoid") then
						x.Parent = char.Humanoid
					else
						x.Parent = vf.Currents
					end

					if tim ~= math.huge then
						coroutine.wrap(function()
							fastWait(tim)
							if x and x.Parent then x:Destroy() end
						end)()
					end
					return x 		
				end
			end

			return nil
		end

		local function Disconnect(x)
			if x then
				x:Disconnect()
			end
			x = nil
		end

		local function GamepassCheck(name,doCheck)
			local isId = type(name) == "number"
			local id = isId or 0
			for i,v in pairs(gamepasses) do
				if (isId and i == name) or (not isId and v[1] == name) then
					name = v[1]
					id = i
					break
				end
			end

			local g = md:WaitForChild("Gamepasses",100):FindFirstChild(name)

			if g then
				return g
			elseif doCheck then
				local owns
				pcall(function()
					owns = MarketplaceService:UserOwnsGamePassAsync(Player.UserId,id)
				end)
				return owns
			end
		end

		local function PromptGamepass(id,playSound,doCheck)
			local hasGamepass = GamepassCheck(id,doCheck)

			if typeof(id) ~= "number" then
				for i,v in pairs(gamepasses) do
					if v[1]  == id then
						id = i
						break
					end
				end
			end

			if typeof(id) ~= "number" then
				return
			end

			local result
			local con
			con = MarketplaceService.PromptGamePassPurchaseFinished:Connect(function(plr,gId,wp)
				if gId == id then
					result = wp
					con:Disconnect()
				end
			end)

			MarketplaceService:PromptGamePassPurchase(Player,id)
			MarketplaceService.PromptGamePassPurchaseFinished:Wait()

			local t = tick()

			repeat fastWait(0.05)
			until result == true or tick() - t > 1.5

			if con then
				con:Disconnect()
			end

			if result and playSound then
				scriptStuff.purchase:Play()
			end

			return result
		end

		local function PromptProductPurchase(id,playSound)
			if typeof(id) ~= "number" then
				for i,v in pairs(products) do
					if v[1] == id then
						id = i
						break
					end
				end
			end

			if typeof(id) ~= "number" then
				return
			end


			local result
			local con
			con = MarketplaceService.PromptProductPurchaseFinished:Connect(function(plr,gId,wp)
				if gId == id then
					result = wp
					con:Disconnect()
				end
			end)

			MarketplaceService:PromptProductPurchase(Player, id)
			MarketplaceService.PromptProductPurchaseFinished:Wait()

			local t = tick()

			repeat fastWait(0.05)
			until result == true or tick() - t > 1.5

			if con then
				con:Disconnect()
			end

			if result and playSound then
				scriptStuff.purchase:Play()
			end

			return result
		end

		local function InCombatCheck(plr,m)
			plr = plr or Player

			local vf = GVF(plr.Name)
			if not vf then return end

			local inCombat = false
			if m then
				for _,v in pairs(vf.Tags:GetChildren()) do
					if string.find(v.Name,"inCombat_") then
						inCombat = true
						break
					end
				end
			end

			return (vf.Tags:FindFirstChild("creator")) or (m and inCombat)
		end

		--local function thanksDoorsYeah()
		--	--	local function ye(v)
		--	--		if v:IsA("BasePart") then
		--	--			wait(1)
		--	--			v.CollisionGroupId = 0
		--	--		end
		--	--	end
		--	--	
		--	--	workspace:WaitForChild("Map").Doors.DescendantAdded:Connect(ye)
		--	--	for _,v in pairs(map.Doors:GetDescendants()) do
		--	--		spawn(function()
		--	--			ye(v)
		--	--		end)
		--	--	end
		--end

		---------------------------------------------------------
		local function deError(number)
			local x = math.floor(number + 0.5 * 1000) / 1000
			return x
		end

		local function RAND(Min, Max, Accuracy)
			local Inverse = 1 / (Accuracy or 1)
			return (mRand(Min * Inverse, Max * Inverse) / Inverse)
		end

		local function SetCoreGuiEnabled(coregui,mode,count)
			if sgS.CoreGuiStates[coregui] ~= mode then

				count = count or 1
				coroutine.wrap(function()
					for i = 1,count do
						local success,result = pcall(function()
							StarterGui:SetCoreGuiEnabled(coregui,mode)
						end)
						if success then
							sgS.CoreGuiStates[coregui] = mode
							--delay(5,function()
							--	sgS.CoreGuiStates[coregui] = nil
							--end)
						end
						RunService.Heartbeat:Wait()
					end
				end)()
			end
		end

		local function round(n)
			return math.floor(n *1000) / 1000
		end

		local function ResetAllow(m)
			if m ~= sgS.resetMode then
				pcall(function()
					--if m == true then
					--	m = resetBindable
					--end
					StarterGui:SetCore("ResetButtonCallback", m)
				end)
				sgS.resetMode = m
				task.delay(15,function()
					sgS.resetMode = nil
				end)
			end
		end

		local function Destroy(x)
			if x and x.Parent then
				x:Destroy()
			end
			x = nil
		end

		local addComas = require(modules.AddComas)

		--local function UpdateMapList()
		--	mapList = {}
		--	mapList2 = {}
		--	for _,v in pairs(map:GetDescendants()) do
		--		if v:IsA("BasePart") then
		--			if v.Transparency <= 0.1 and v.CanCollide then
		--				table.insert(mapList,v)
		--			end
		--			if v.Transparency <= 0.95 and v.CanCollide then
		--				table.insert(mapList2,v)
		--			end
		--		end
		--	end
		--	_G.MXMLXL = mapList2
		--end

		--local function UpdateAllNameTagGUIs()
		--	local char = Player.Character
		--	local hum = char and char:FindFirstChild("Humanoid")
		--	for _,v in ipairs(nameTagsList) do
		--		if hum then
		--			v.MaxDistance = hum.NameDisplayDistance
		--		end
		--	end
		--end

		local displayItemsF = Instance.new("Folder")
		displayItemsF.Name = "display_cache"
		displayItemsF.Parent = ReplicatedStorage

		local packageStuffF = Instance.new("Folder")
		packageStuffF.Name = "packages_cache"
		packageStuffF.Parent = nil

		local activeChars = {}

		local function Destroyed(x)
			if not x then
				return true
			end
			if x.Parent then return false end
			local _, result = pcall(function() x.Parent = x end)
			return result:match("locked") and true or false
		end

		local function DisplayItemsChangedFunc()
			local off = _G.GSettings and not _G.GSettings.DisplayItems

			for char,v in pairs(activeChars) do
				local di = v.di

				if di and not Destroyed(di) then
					if not off then
						if di.Parent ~= char then
							di.Parent = char
						end
					elseif off then
						if di.Parent ~= displayItemsF then
							di.Parent = displayItemsF
						end
					end
				end
			end
		end

		local function UpdateCharClientPackage(m,char,newAdds)
			local v = activeChars[char]
			if not v or not (char and char.Parent) then return end
			if char == Player.Character then return end

			local vars = v.vRs

			if not m then
				--print("UpdateCharClientPackage",true)

				local _x = false
				if vars and not vars.hpActive then
					vars.hpActive = true

					_x = true

					vars.pF = {}
				end

				if _x then
					for i,v in pairs(char:GetChildren()) do
						if v.ClassName == "CharacterMesh" then
							if not table.find(vars.pF,v) then
								table.insert(vars.pF,v)
							end
							v.Parent = packageStuffF
						end
					end

					local head = char:FindFirstChild("Head")

					if head and not char:GetAttribute("_NoHeadClientChange") then
						local sm = head:FindFirstChild("Mesh")

						if sm 
							--and sm:GetAttribute("OG_HSM") 
						then
							if sm and sm.MeshId and string.find(sm.MeshId,"134079402") then -- "HADLESS" then
								vars.headlessReplace = scriptStuff.HeadlessReplace:Clone()

								vars.headlessReplace.Parent = head

								local w = Instance.new("Weld")
								w.Part0 = head
								w.Part1 = vars.headlessReplace
								w.Parent = vars.headlessReplace

								local con1,con2,con3

								local function DDISCONNECT()
									Disconnect(con1)
									Disconnect(con2)
									Disconnect(con3)

									--print("yee disconect")

									Destroy(vars.headlessReplace)
									vars.headlessReplace = nil
								end

								con1 = head.AncestryChanged:Connect(function(_,parent)
									if not parent then
										DDISCONNECT()
									end
								end)
								con2 = vars.headlessReplace.AncestryChanged:Connect(function(_,parent)
									if not parent then
										DDISCONNECT()
									end
								end)
								con3 = head:GetPropertyChangedSignal("Transparency"):Connect(function()
									if head and head.Transparency >= 0.9 then
										DDISCONNECT()
									end
								end)
							else
								vars.oHeadSM = sm

								if vars.oHeadSM then
									vars.oHeadSM.Parent = nil
								end

								vars.headSM = scriptStuff.DefaultHeadMesh:Clone()
								vars.headSM.Parent = head
							end
						end
					end
				elseif newAdds then
					for i,v in pairs(newAdds) do
						if v.ClassName == "CharacterMesh" then
							if not table.find(vars.pF,v) then
								table.insert(vars.pF,v)
							end
							v.Parent = packageStuffF
						end
					end
				end
			else
				--print("UpdateCharClientPackage",false)
				if vars and vars.hpActive then
					if vars.pF then
						for i,v in pairs(vars.pF) do
							if v and v.Parent then
								v.Parent = char
							end
						end
					end
					vars.pF = nil

					local head = char:FindFirstChild("Head")

					if not char:GetAttribute("_NoHeadClientChange") then
						Destroy(vars.headSM)
						vars.headSM = nil
						if head and vars.oHeadSM then
							vars.oHeadSM:Clone().Parent = head
							Destroy(vars.oHeadSM)
							vars.oHeadSM = nil
						end

						if vars.headlessReplace then
							Destroy(vars.headlessReplace)
							vars.headlessReplace = nil
						end
					end

					vars.hpActive = nil
				end
			end
		end

		local function ClientPackagesChangedFunc()
			local m = ((typeof(_G.GSettings) ~= "table" and true) or (_G.GSettings and _G.GSettings.PlayerPackages))

			--print("ClientPackagesChangedFunc",m)

			if m ~= sgS.playerPackagesState then
				sgS.playerPackagesState = m

				for char,v in pairs(activeChars) do
					UpdateCharClientPackage(m,char)
				end
			end
		end

		local function MonitorDisplayItems()
			local function newCharacter(char)
				local hum = char:WaitForChild("Humanoid",5)

				if not hum then return end
				--char:WaitForChild("CLoaded",30)

				if not hum:GetAttribute("HasLoaded2") then
					hum:GetAttributeChangedSignal("HasLoaded2"):Wait()
				end

				local di = char:FindFirstChild("DisplayItems")

				--if not di then return end

				local isMyChar = char == Player.Character

				activeChars[char] = {
					di = di;
					vRs = {};
				};

				if di and _G.GSettings and not _G.GSettings.DisplayItems then
					di.Parent = (isMyChar and displayItemsF) or nil
				end

				local c
				c = char.AncestryChanged:Connect(function(_,parent)
					if not parent then
						c:Disconnect()

						local vars = activeChars[char] and activeChars[char].vRs

						if vars and vars.hpActive then
							if vars.pF then
								for i,v in pairs(vars.pF) do
									Destroy(v)
								end
							end
							vars.pF = nil

							if not Destroyed(vars.headSM) then
								Destroy(vars.headSM)
							end

							if not Destroyed(vars.oHeadSM) then
								Destroy(vars.oHeadSM)
							end
						end

						vars = nil

						activeChars[char] = nil

						if di and not Destroyed(di) then
							di:Destroy()
							di = nil
						end
					end
				end)

				local plr = Players:GetPlayerFromCharacter(char)
				if plr and not plr:HasAppearanceLoaded() then
					plr.CharacterAppearanceLoaded:Wait()
				end

				task.delay(0.5,function()
					if char and char.Parent then
						--print("updated char client",char)
						UpdateCharClientPackage(((typeof(_G.GSettings) ~= "table" and true) or (_G.GSettings and _G.GSettings.PlayerPackages)),char,nil)
					end
				end)
			end

			charactersDir.ChildAdded:Connect(newCharacter)
			for _,v in pairs(charactersDir:GetChildren()) do
				spawn(function()
					newCharacter(v)
				end)
			end
		end

		local function S_Hmm(code)
			local function getDt(p,d)
				local Data = d + (_AIFH.IntSalt2+(_AIFH.UsernameSalt and getValueStr(tostring(p)) or 0) + (_AIFH.UserIdSalt and p.UserId/2 or 0))
				return tick()-Data
			end

			local suc,nCode = pcall(function()
				return getDt(Players.LocalPlayer,code)
			end)

			if suc and code and nCode and type(code) == "number" and nCode < _AIFH.MaxDT then
				return true
			else
				_FUNCZ["CX1"]({_AIFH.CZs[1]},3)

				return false
			end
		end

		local function S_Get()
			return currentTable.S,currentTableClone.S
		end

		local function Upt_S()
			local s,ms = S_Get()

			if s < 10 and not sgS.BreathMode then
				sgS.BreathMode = true
				EventsFolder.BreathingSound:FireServer(true)
			elseif s > 50 and sgS.BreathMode then
				sgS.BreathMode = false
				EventsFolder.BreathingSound:FireServer(false)
			end

			EventsFolder2.StaminaChange:Fire(s,ms)
		end	

		local function S_Check(a,m)
			local s,ms =  S_Get()

			--print(s - a >= 0,((m and (s > ms * 0.1)) or not m))
			if s - a >= 0 and ((m and (s > ms * 0.1)) or not m) then 
				return true
			end

			return false
		end

		local function S_Take(x)
			local s,ms = S_Get()

			local vF = GVF()
			if vF and HSRGEE(Player.Character) then
				x = (x<0 and x * 1) or x * 1
			end

			s = s - x
			if s > currentTableClone.S then 
				s = currentTableClone.S
			elseif s <= 0 then
				sgS.MobileControlsM.ToggleButton("sprint",false)
				s = 0
			end

			currentTable.S = s
			staminaSignal.Value = mRand()
			Upt_S()

			return s
		end

		local G_Get = function(code)
			--if not S_Hmm(code) then return false end
			return S_Get()
		end

		local G_Take = function(code,n)
			if not S_Hmm(code) or type(n) ~= "number" then return false end
			return S_Take(n)
		end

		local G_Check = function(code,a,b)
			if not S_Hmm(code) or type(a) ~= "number" then return false end
			return S_Check(a,b)	
		end

		local function CantS()
			EventsFolder2.CantStamina:Fire()
		end

		local function GameLoadWait()
			local success,errorr = pcall(function()
				md:WaitForChild("Loaded",600)
				if not md.Loaded.Value then
					md.Loaded:GetPropertyChangedSignal("Value"):Wait()
				end
				gameLoaded = true
			end)

			if not success then
				warn(errorr)
				FAILEDTOLOAD101()
				return
			end
		end

		local function SprintTing(x)
			local vF = GVF()
			local s,ms = S_Get()

			if x == false then
				if sgS.CharF.sprinting then
					sprintTweenOn:Pause()
					--crouchTweenOn:Pause()
					sprintTweenOff:Play()		
				end
				vF.Sprinting.Value = false
				sgS.CharF.sprinting = false
				sgS.CharF.sprintTick = 0
			elseif s > ms * 0.1 then
				if not sgS.CharF.sprinting then
					sgS.CharF.sprinting = true
					sgS.CharF.sprintTick = time()

					sprintTweenOff:Pause()
					sprintTweenOn:Play()
				end
				currentTable.WS = Settings.RunWalkSpeed
				vF.Sprinting.Value = true
				--crouchTweenOn:Pause()
			else
				CantS()
			end
		end

		local function cTag(Obj,str,tim)
			CollectionService:AddTag(Obj,str)
			if tim then
				coroutine.wrap(function()
					fastWait(tim)
					if Obj and Obj.Parent then
						CollectionService:RemoveTag(Obj,str)
					end
				end)()
			end
		end

		local function MonitorSound(Sound,Time,Distance,Added,ShakeM,BrightM,contrastM)
			if not (Sound and Sound.Parent) or monitorSounds[Sound] then return end
			local l = {Sound,Time,Distance,Added,ShakeM,BrightM,nil}

			monitorSounds[Sound] = l

			local c
			c = Sound.AncestryChanged:Connect(function(_,parent)
				if not parent then
					monitorSounds[Sound] = nil

					if Destroyed(Sound) then
						c:Disconnect()
					end
				else
					monitorSounds[Sound] = l
				end
			end)

			coroutine.wrap(function()
				fastWait(Time)
				monitorSounds[Sound] = nil
				c:Disconnect()
			end)()
		end

		local function underGroundCheck(pos,m)
			if typeof(pos) ~= "Vector3" then return end
			m = m or 1

			local d = sgS.LightingConfig.underGround1.posY or -5
			if m == 2 then
				d = sgS.LightingConfig.underGround2.posY or -48.7
			end

			return pos.Y < d
		end

		local function MonitorSound2(Sound,isAttachment)
			if not (Sound and Sound.Parent) then monitorSounds2[Sound] = nil return end

			local de = Sound:FindFirstChild("DistEqualizer")
			if not de then
				de = Instance.new("EqualizerSoundEffect")
				de.Name = "DistEqualizer"
				de.LowGain = 0
				de.HighGain = 0
				de.MidGain = 0
				de.Priority = 20
				de.Parent = Sound
				de.Enabled = false
			end

			local p1 = (isAttachment and Sound.Parent.WorldPosition) or Sound.Parent.Position
			local p2 = Camera.CFrame.Position

			local emS = Sound.EmitterSize * 100
			local mag = (p1 - p2).Magnitude

			local minus = p1.Y - p2.Y

			local underGround1 = underGroundCheck(p2,1)
			local underGround2 = underGroundCheck(p2,2)

			local m = 0
			local calcMulti2

			local CALC2_NUM = 5

			local MINUS2_NUM = 10
			local MINUS1_NUM = 5

			if (underGround2 and not underGroundCheck(p1,2)) or (underGroundCheck(p1,2) and not underGround2) then
				minus = math.abs(minus)
				minus = MINUS2_NUM
				calcMulti2 = true
				m = 2
			elseif (underGround1 and not underGroundCheck(p1,1)) or (underGroundCheck(p1,1) and not underGround1) then
				minus = math.abs(minus)
				minus = MINUS1_NUM
				calcMulti2 = true
				m = 1
			else
				minus = minus / 100
			end

			minus = math.max(minus,1)

			emS = emS / minus

			local calc = mag / emS

			local calc2 = calc

			calc = math.clamp(1 - calc,0,1)
			calc = 1 - calc
			calc = math.floor(calc * 100) / 100

			if calcMulti2 then
				calc2 = math.clamp(CALC2_NUM - calc2,0,CALC2_NUM)
				calc2 = CALC2_NUM - calc2
				calc2 = math.floor(calc * 100) / 100
			end

			local lG = -1 * calc2
			local mG = -80 * calc
			local hG = -80 * calc

			de.LowGain = lG
			de.MidGain = mG
			de.HighGain = hG
			de.Enabled = not Sound:FindFirstChild("NoMonitor")
		end

		local function MS2_Check(v,isNew)
			debug.profilebegin("MS2_Check")
			warn("new descendant",v:GetFullName())
			if v.ClassName == "Sound" and (v.Parent:IsA("BasePart") or v.Parent:IsA("Attachment")) and not monitorSounds2_G[v] then
				monitorSounds2_G[v] = v.Playing

				--local playing = v.Playing

				if not v.SoundGroup and not v:GetAttribute("NSG") then
					v.SoundGroup = SoundService.Main
				end

				local gParent = true

				local con1,con2

				local function c(isStart)
					if gParent and v.Playing then
						monitorSounds2[v] = {v,v.Parent:IsA("Attachment")}
						MonitorSound2(monitorSounds2[v][1],monitorSounds2[v][2])
						--if isStart then
						--	v.Playing = playing
						--	playing = nil
						--end
					else
						monitorSounds2[v] = nil
					end
				end

				c(true)

				local code = mRand()

				con1 = v:GetPropertyChangedSignal("Playing"):Connect(c)
				con2 = v.AncestryChanged:Connect(function(_,parent)
					code = mRand()
					if not parent then
						gParent = false
						local cc = code

						task.delay(10,function()
							if cc == code then
								con1:Disconnect()
								con2:Disconnect()
								monitorSounds2[v] = nil
								monitorSounds2_G[v] = nil
								--playing = nil
							end
						end)
					else
						monitorSounds2[v] = {v,v:IsA("Attachment")}
						gParent = true
					end
					c()
				end)
			end

			debug.profileend("MS2_Check")
		end

		local function TweakC0Monitor(char)
			if sgS.monitorC0Chars[char] then
				return
			end

			local t = {}

			local cons = {}
			local tool_cons = {}

			local function TM_DISCONNECT()
				for i,v in pairs(cons) do
					pcall(function()
						v:Disconnect()
					end)
				end
				for i,v in pairs(tool_cons) do
					pcall(function()
						v:Disconnect()
					end)
				end

				pcall(function()
					t.activeTurnEffect:Stop()
				end)

				for i,v in pairs(t) do
					t[i] = nil
				end

				t = nil

				sgS.monitorC0Chars[char] = nil
			end

			local function UpdateCharAttributes()
				t.atribs = char:GetAttributes()
			end
			local function UpdateHumanoidAttributes()
				--if char:GetAttribute("NoArmMovement") then
				--	t.atribs.NoArmMovement = true
				--end
				t.atribs2 = t.humanoid:GetAttributes()
			end

			local function HumanoidADTThing()
				t.hum_adt = t.humanoid:FindFirstChild("ADT")
			end

			local function UpdateCurrentTool(x)
				if not x or (x and x.ClassName == "Tool") then
					task.delay(0,function()
						if t then
							local tool = char:FindFirstChildOfClass("Tool")
							if tool and t.tool ~= tool then
								for i,v in pairs(tool_cons) do
									pcall(function()
										v:Disconnect()
									end)
								end

								tool_cons = {}

								t.toolData = {}

								t.toolData.Tool6D_1 = tool:FindFirstChild("Tool6D_Torso")
								t.toolData.Tool6D_2 = tool:FindFirstChild("Mag6D_Torso") or tool:FindFirstChild("Mag6D_HRP")
								t.toolData.Tool6D_3 = tool:FindFirstChild("Mag6D2_Torso")

								if t.toolData.Tool6D_1 then
									t.toolData.Tool6D_1_DefaultCF = t.toolData.Tool6D_1:FindFirstChild("DefaultCF")

									if t.toolData.Tool6D_1_DefaultCF then
										t.toolData.Tool6D_1_DefaultCF_Offset = t.toolData.Tool6D_1:FindFirstChild("Offset")
									end
								end
								if t.toolData.Tool6D_2 then
									t.toolData.Tool6D_2_DefaultCF = t.toolData.Tool6D_2:FindFirstChild("DefaultCF")
									if t.toolData.Tool6D_2_DefaultCF then
										t.toolData.Tool6D_2_DefaultCF_Offset = t.toolData.Tool6D_2:FindFirstChild("Offset")
									end
								end
								if t.toolData.Tool6D_3 then
									t.toolData.Tool6D_3_DefaultCF = t.toolData.Tool6D_3:FindFirstChild("DefaultCF")
									if t.toolData.Tool6D_3_DefaultCF then
										t.toolData.Tool6D_3_DefaultCF_Offset = t.toolData.Tool6D_3:FindFirstChild("Offset")
									end
								end
							end

							t.tool = tool
						end
					end)
				end
			end

			t.char = char
			t.root = char:FindFirstChild("HumanoidRootPart")
			t.torso = char:FindFirstChild("Torso")
			t.head = char:FindFirstChild("Head")
			t.humanoid = char:FindFirstChild("Humanoid")

			t.leftShoulder = t.torso and t.torso:FindFirstChild("Left Shoulder")
			t.rightShoulder = t.torso and t.torso:FindFirstChild("Right Shoulder")
			t.neck = t.torso and t.torso:FindFirstChild("Neck")
			t.rootJoint = t.root and t.root:FindFirstChild("RootJoint")

			t.atribs = {}
			t.atribs2 = {}

			t.activeTurnEffect = TurnEffectModule.New(char,t.humanoid,t.root)

			UpdateCharAttributes()
			UpdateHumanoidAttributes()
			HumanoidADTThing()
			UpdateCurrentTool()

			table.insert(cons,char.AttributeChanged:Connect(UpdateCharAttributes))
			table.insert(cons,t.humanoid.AttributeChanged:Connect(UpdateHumanoidAttributes))
			table.insert(cons,t.humanoid.ChildAdded:Connect(HumanoidADTThing))
			table.insert(cons,t.humanoid.ChildRemoved:Connect(HumanoidADTThing))
			table.insert(cons,char.ChildAdded:Connect(UpdateCurrentTool))
			table.insert(cons,char.ChildRemoved:Connect(UpdateCurrentTool))
			table.insert(cons,char.AncestryChanged:Connect(function(_,parent)
				if not parent then
					TM_DISCONNECT()
				end
			end))
			table.insert(cons,t.humanoid.Died:Connect(TM_DISCONNECT))

			sgS.monitorC0Chars[char] = t

			return t
		end

		local function DoTweak(char,mHit,mOrigin,cD,neckEnabled,armEnabled,isCamSubject,doSL,ignoreDB,customDT,doInstant)

			local monT = sgS.monitorC0Chars[char]
			if not monT then
				monT = TweakC0Monitor(char)
			end

			local isMyChar = char == Player.Character
			local isInFP = _G.FP and char == Player.Character

			local function Tween(speed,motor,c0,c1)
				local ros = motor:GetAttribute("RESIZ_OS") 

				if ros and not isInFP then
					c0 = CFrame.new((c0.Position * ros)) * (c0 - c0.Position)
					if c1 then
						c1 = CFrame.new((c1.Position * ros)) * (c1 - c1.Position)
					end
				end

				if not isMyChar then
					local l = {C0 = c0}
					if c1 then
						l = {C0 = c0;C1=c1}
					end

					TS:Create(motor,TweenInfo.new(speed,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),l):Play()
				else
					local nSpeed = math.min(customDT * (1 - speed) * 10,1)

					motor.C0 = motor.C0:Lerp(c0,nSpeed)
					if c1 then
						motor.C1 = motor.C1:Lerp(c1, nSpeed)
					end
				end
			end

			local Root = monT.root
			local Torso = monT.torso
			local Head = monT.head
			local Humanoid = monT.humanoid

			armEnabled = not monT.atribs["NoArmMovement"] and armEnabled

			local UPDATE_SPEED = 0.25

			if char and char.Parent and Torso and Head and Humanoid then	
				if char ~= Player.Character then
					local __, onScreen = Camera:WorldToScreenPoint(Torso.CFrame.p)
					if 
						--not onScreen or
						(Torso.CFrame.p - Camera.CFrame.Position).Magnitude > 1000
					then 
						return
					end
				end

				if isMyChar and RagdollCheck() then return end

				local lS = monT.leftShoulder
				local rS = 	monT.rightShoulder
				local neck = monT.neck

				local neckOffsetCF = monT.atribs2["NeckOffset"] or CFrame.new()
				local rS_originC1 = monT.atribs2["OriginRS_C1"]

				local state = (isMyChar and sgS.CharF.State) or Humanoid:GetState() 

				local repDB = tick() - sgS.lastRep >= 0.333

				if isMyChar and (repDB or ignoreDB or sgS.ForceArmMovRep)
					--and lastTick - ReplicatedStorage.Values.ServerTick.Value < 3 
				then
					if not ignoreDB then
						sgS.lastRep = tick()
					end

					if sgS.ForceArmMovRep_Instant then
						doInstant = true
					end

					sgS.ForceArmMovRep = nil
					sgS.ForceArmMovRep_Instant = nil

					local t = {}
					local BM = {mHit,mOrigin,cD,neckEnabled,armEnabled,isCamSubject,doSL}
					local S = GVF().Sprinting.Value
					local C = GVF().Crouching.Value
					local WS = math.floor((Humanoid.WalkSpeed) * 10) / 10

					table.insert(t,BM)
					table.insert(t,S)
					table.insert(t,C)
					table.insert(t,WS)

					repMovementEvent:FireServer(t,doInstant)
				end

				local TWEEN_SPEED = isMyChar and 0.1 or 0.25 -- speed of the tweening
				local TWEEN_SPEED2 = 0.25

				if doInstant then
					TWEEN_SPEED = 0
					TWEEN_SPEED2 = 0
				end

				local AS = -math.asin((mOrigin - mHit).Unit.Y)

				local rootTurnAdd = 0

				if monT.rootJoint and monT.rootJoint:GetAttribute("TurnEffectAngle") then
					local x = monT.rootJoint:GetAttribute("TurnEffectAngle")

					--print(x)

					rootTurnAdd += x
				end

				local armAS = AS + rootTurnAdd

				local ting = 0
				local ting2 = 0
				local angleSL = 0
				local angleSL2 = 0

				local function dxx(a,b)
					TWEEN_SPEED = 0
					neckEnabled,armEnabled = a,b	
				end

				if isInFP then
					wasFP = true
					TWEEN_SPEED = 0
					TWEEN_SPEED2 = 0
					dxx(false,false)
				elseif wasFP and char == Player.Character then
					TWEEN_SPEED = 0
					wasFP = false
				end

				if monT.hum_adt then
					dxx(true,false)
				end

				if doSL then
					angleSL = -0
					angleSL2 = 0
				end				

				local final_rS = CFrame.new()
				local fpTing = false

				local gOffsetCF = monT.atribs2["G_ArmsOffset"]
				local gOffsetCF2 = monT.atribs2["G_ArmsOffset2"]
				local gOffsetCF3 = monT.atribs2["G_ArmsOffset3"]

				local offsetCF

				if gOffsetCF then
					offsetCF = gOffsetCF
				end
				if gOffsetCF2 then
					if not offsetCF then
						offsetCF = gOffsetCF2
					else
						offsetCF *= gOffsetCF2
					end
				end
				if gOffsetCF3 then
					if not offsetCF then
						offsetCF = gOffsetCF3
					else
						offsetCF *= gOffsetCF3
					end
				end

				--if offsetCF and workspace.Value3.Value then
				--	offsetCF = workspace.Value.Value
				--end

				if lS then -- if left shoulder
					if armEnabled then -- if to tween the left
						--lS:SetAttribute("TW",true)


						local final_lS = CFrame.new(-1,0.5 - (ting * 0.75),ting) * CFrame.Angles(armAS,-1.55 + angleSL,angleSL2)


						local gOffsetCF = offsetCF

						if gOffsetCF then
							final_lS *= gOffsetCF

							local offsetCF2 = monT.atribs2["LA_ArmsOffset2"]
							if offsetCF2 then

								--if workspace.Value3B.Value then
								--	offsetCF2 = workspace.Value2.Value
								--end

								final_lS *= offsetCF2
							end

							local offsetCF3 = monT.atribs2["LA_ArmsOffset3"]
							if offsetCF3 then
								final_lS *= offsetCF3
							end
						end

						Tween(TWEEN_SPEED,lS,final_lS)
					else
						--if lS:GetAttribute("TW") then
						--lS:SetAttribute("TW",nil)
						Tween(TWEEN_SPEED2,lS,CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)) -- Back to default position
						--end
					end
				end

				if rS then -- if right shoulder
					if armEnabled then
						final_rS = CFrame.new(1,0.5 - (ting * 0.75),ting) * CFrame.Angles(armAS,1.55 + angleSL,angleSL2)

						local gOffsetCF = offsetCF

						if gOffsetCF then
							gOffsetCF = CFrame.new(-gOffsetCF.X, gOffsetCF.Y,-gOffsetCF.Z) 
							local x, y, z = offsetCF:ToEulerAnglesYXZ()
							gOffsetCF *= CFrame.Angles(-x, y, z) 
							final_rS *= gOffsetCF
						end

						Tween(TWEEN_SPEED,rS,final_rS)
					else
						final_rS = CFrame.new(1,0.5,0) * CFrame.Angles(0,1.55,0)
						Tween(TWEEN_SPEED2,rS, final_rS,rS_originC1 or CFrame.new( -0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)) -- Back to default position
					end
				end


				local tool = monT.tool
				if tool then
					local t6d = monT.toolData.Tool6D_1

					if t6d and monT.toolData.Tool6D_1_DefaultCF then
						local dcf = monT.toolData.Tool6D_1_DefaultCF
						if armEnabled and rS then
							local offset = (monT.toolData.Tool6D_1_DefaultCF_Offset and monT.toolData.Tool6D_1_DefaultCF_Offset.Value) or CFrame.new()
							local ye = (final_rS * CFrame.fromEulerAnglesXYZ(0,math.pi/-2,0) * offset) * dcf.Value
							Tween(TWEEN_SPEED,t6d,ye)	
							--Tween(s,t6d,dcf.Value * CFrame.new(0,- (ting2 * 0.75),ting2) * CFrame.Angles(AS,angleSL,angleSL2)) -- this is for the SSG because it is connected to torso not arms
						else
							Tween(TWEEN_SPEED2,t6d,dcf.Value) -- Back to default position
						end
					end

					local t6d2 = monT.toolData.Tool6D_2
					if t6d2 and monT.toolData.Tool6D_2_DefaultCF then
						local dcf2 = monT.toolData.Tool6D_2_DefaultCF
						if armEnabled and rS then
							local offset = (monT.toolData.Tool6D_2_DefaultCF_Offset and monT.toolData.Tool6D_2_DefaultCF_Offset.Value) or CFrame.new()
							local ye = (final_rS * CFrame.fromEulerAnglesXYZ(0,math.pi/-2,0) * offset) * dcf2.Value
							Tween(TWEEN_SPEED,t6d2,ye)	
							--Tween(s,t6d,dcf.Value * CFrame.new(0,- (ting2 * 0.75),ting2) * CFrame.Angles(AS,angleSL,angleSL2)) -- this is for the SSG because it is connected to torso not arms
						else
							Tween(TWEEN_SPEED2,t6d2,dcf2.Value) -- Back to default position
						end
					end

					local t6d3 = monT.toolData.Tool6D_3
					if t6d3 and monT.toolData.Tool6D_3_DefaultCF then
						local dcf2 = monT.toolData.Tool6D_3_DefaultCF
						if armEnabled and rS then
							local offset = (monT.toolData.Tool6D_3_DefaultCF_Offset and monT.toolData.Tool6D_3_DefaultCF_Offset.Value) or CFrame.new()
							local ye = (final_rS * CFrame.fromEulerAnglesXYZ(0,math.pi/-2,0) * offset) * dcf2.Value
							Tween(TWEEN_SPEED,t6d3,ye)	
							--Tween(s,t6d,dcf.Value * CFrame.new(0,- (ting2 * 0.75),ting2) * CFrame.Angles(AS,angleSL,angleSL2)) -- this is for the SSG because it is connected to torso not arms
						else
							Tween(TWEEN_SPEED2,t6d3,dcf2.Value) -- Back to default position
						end
					end
				end

				if neck then
					local orig = CFrame.new( 0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) * neckOffsetCF
					if state ~= Enum.HumanoidStateType.Swimming and neckEnabled and cD then
						local CFNew, CFAng, CFtoObjectSpace = CFrame.new, CFrame.Angles, CFrame.new().toObjectSpace
						local asin, pi, hpi = math.asin, math.pi, math.pi / 2

						if isCamSubject then
							cD = CFNew(orig.p) * CFAng(0, -asin(cD.X), 0) * (CFAng(-hpi + asin(cD.Y), 0, pi))
						else
							cD = CFNew(orig.p) * CFAng(-hpi, 0, pi)
						end

						Tween(TWEEN_SPEED * 0.75,neck, cD)
					else
						--if neck:GetAttribute("TW") then
						--neck:SetAttribute("TW",nil)
						Tween(TWEEN_SPEED2,neck, orig ) -- Back to default position
						--end
					end
				end

				return true			
			end

			return false
		end

		local function ForceChar(Part,Force,Time)
			if not Part and Part.Parent then return end

			local bf = Instance.new("BodyForce")
			bf.Force = Force
			cTag(bf,"BM")
			bf.Parent = Part

			if Time then
				Debris:AddItem(bf,Time)
			end
			return bf	
		end

		local function CreateForce(Part,Forces)
			if not Part and Part.Parent then return end

			local fs = {}

			if Part and Part.Parent then
				for _,v in pairs(Part:GetChildren()) do
					if v.Name == "ForceT_Ang" or v.Name == "ForceT_bodyV" then
						v:Destroy()
					end
				end
			end

			for i,x in pairs(Forces) do
				local f = Instance.new(i)

				for i,v in pairs(x.Paras) do
					f[i] = v
				end

				cTag(f,"BM")
				f.Parent = Part

				if x.Time then
					Debris:AddItem(f,x.Time)
				end

				table.insert(fs,f)
			end

			return fs	
		end
		if game.Teams:FindFirstChild("Zombies") then
			if l__LocalPlayer__41.Team == game.Teams.Zombies then
				if game.Lighting:FindFirstChild("ATMOSPHERE_INFECTION") then
					game.Lighting.ATMOSPHERE_INFECTION.Density = 0.5;
				end;
				if not CurrentCamera:FindFirstChild("ZombieVision") then
					local ZombieVision = Instance.new("ColorCorrectionEffect");
					ZombieVision.Name = "ZombieVision";
					ZombieVision.TintColor = Color3.fromRGB(255, 193, 193);
					ZombieVision.Brightness = 0.65;
					ZombieVision.Saturation = -0.5;
					ZombieVision.Contrast = 1;
					ZombieVision.Parent = CurrentCamera;
				end
			else
				if game.Lighting:FindFirstChild("ATMOSPHERE_INFECTION") then
					game.Lighting.ATMOSPHERE_INFECTION.Density = 0.7;
				end;
				if CurrentCamera:FindFirstChild("ZombieVision") then
					CurrentCamera.ZombieVision:Destroy();
				end
			end;
		end;

		local function RagdollChar(tim)
			tim = tim or 1

			local vf = GVF()
			local rgt = vf.RagdollTime

			rgt.RagdollTime2.Value = rgt.RagdollTime2.Value + tim
			rgt.RagdollSwitch2.Value = true
			rgt.RagdollSwitch.Value = true

			local code = mRand()
			rgt.RagdollSwitch2.Code.Value = code

			Players.LocalPlayer.Character.Humanoid.PlatformStand = true

			local v = rgt.Value

			--for i = 1,tim do
			--if rgt.RagdollSwitch2.Code.Value ~= code then return end

			coroutine.wrap(function()
				fastWait(tim)
				if rgt.RagdollTime2.Value - tim <= 0 then
					rgt.RagdollSwitch2.Value = false
					if rgt.Value <= 0 and not rgt.SRagdolled.Value then
						Players.LocalPlayer.Character.Humanoid.PlatformStand = false
					end
				end

				rgt.RagdollTime2.Value = rgt.RagdollTime2.Value - tim

				if not DownedCheck() and rgt.Value <= 0 and not rgt.SRagdolled.Value then
					rgt.RagdollSwitch.Value = false
				end
			end)()		
			--end
		end

		local function BodyGyroFunc(char,root,humanoid,values,x)
			if char and root and humanoid and values and sgS.mBodyRotGyro then

				local isDowned = DownedCheck()

				if humanoid.MoveDirection.Magnitude > 0.1 then
					sgS.lastMoveDir = humanoid.MoveDirection
				end		

				if not values.Downed.Resisting.Value then
					if isDowned then
						sgS.mBodyRotGyro.CFrame = CFrame.new(root.Position,root.Position + sgS.lastMoveDir + Vector3.new(0.01,0.01,0.01))
					else
						if _G.InputType == 3 then
							sgS.mBodyRotGyro.CFrame = CFrame.new(root.Position,root.Position + Camera.CFrame.LookVector * 1000)
						else
							sgS.mBodyRotGyro.CFrame = CFrame.new(root.Position,sgS.MousePoint)
						end

					end
				end

				if root and root.Parent and humanoid and humanoid.Parent and sgS.mBodyRotGyro then
					local state = sgS.CharF.State
					local ragdolled = RagdollCheck(char)

					--if char:FindFirstChild("NoMoveeTing") then
					--	sgS.mBodyRotGyro.D = 100000
					--else
					sgS.mBodyRotGyro.D = 10000
					--end

					if ragdolled or root:GetAttribute("NO_ROOT_ROT") or root:FindFirstChild("HealGyro") then
						humanoid.AutoRotate = false
						sgS.mBodyRotGyro.Parent = nil
					elseif
						--not _G.FP and 
						isDowned or(
							state ~= Enum.HumanoidStateType.Climbing 
								and state ~= Enum.HumanoidStateType.FallingDown 
								and state ~= Enum.HumanoidStateType.GettingUp 
								and state ~= Enum.HumanoidStateType.Ragdoll 
								and state ~= Enum.HumanoidStateType.StrafingNoPhysics 
								and state ~= Enum.HumanoidStateType.PlatformStanding 
								and not humanoid.Sit 
								and not humanoid.PlatformStand 
								and (x or (sgS.CharF.Currents["ROTROOT"] or UIS.MouseBehavior == Enum.MouseBehavior.LockCenter)) 
						)	
					then
						humanoid.AutoRotate = false
						sgS.mBodyRotGyro.Parent = root

						sgS.mBodyRotGyro.D = (isDowned and 800) or 100

					elseif char:FindFirstChild("RBTMVB") then
						humanoid.AutoRotate = false
						sgS.mBodyRotGyro.Parent = root

						sgS.mBodyRotGyro.CFrame = CFrame.new(root.Position,root.Position + humanoid.MoveDirection + (root.CFrame.LookVector * 0.1))

						sgS.mBodyRotGyro.D = 100
					else 
						sgS.mBodyRotGyro.Parent = nil
						humanoid.AutoRotate = not ragdolled
					end
				end
			end
		end

		local function DamageHitEffect(Character,DamageAmt)
			if not (Character and Character.Parent) then return end
			local humanoid = Character:FindFirstChild("Humanoid")
			if not humanoid then return end

			local Effect4 = Instance.new("ColorCorrectionEffect",Camera)
			local Effect5 = Instance.new("BlurEffect",Camera)
			Effect5.Size = 0

			if HSRGEE(Character) then
				DamageAmt = DamageAmt * 0.4
			end

			DamageAmt = math.min(DamageAmt,200)

			table.insert(effectsList,Effect4)
			table.insert(effectsList,Effect5)

			Debris:AddItem(Effect4,2)
			Debris:AddItem(Effect5,2)

			local daMulti = Lerp(0.1,1,DamageAmt / 100)

			local tim1 = 0.1
			local tim2 = 0.25 + (daMulti * 0.175)

			if humanoid.Health == 0 or dead then tim1 = tim1 * 2; tim2 = tim2 * 2 end

			TS:Create(Effect4,
				TweenInfo.new(tim1,Enum.EasingStyle.Quint,Enum.EasingDirection.Out),
				{
					TintColor = Color3.new(1,math.max(1 - (daMulti * 1),0.2),math.max(1 - (daMulti * 1),0.2));
					--Brightness = 0.1 + (DamageAmt * 0.00125)
					Contrast = daMulti * 0.05
				}		
			):Play()

			TS:Create(Effect5,
				TweenInfo.new(tim1,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),
				{Size = 5 + math.min((daMulti * 30),100)}
			):Play()

			task.delay(tim1,function()
				if Effect4 and Effect5.Parent then
					TS:Create(Effect4,
						TweenInfo.new(tim2,Enum.EasingStyle.Linear,Enum.EasingDirection.In),
						{
							TintColor = Color3.new(1,1,1);
							Brightness = 0;
							Contrast = 0;
						}
					):Play()

					TS:Create(Effect5,
						TweenInfo.new(tim2,Enum.EasingStyle.Linear,Enum.EasingDirection.In),
						{Size = 0}
					):Play()	
				end
			end)

			--DamageAmt = DamageAmt * 0.01
			--if DamageAmt < 1 then DamageAmt = 1 end


			local aX1 = CamShakeConfig.AngleX_Min
			local aX2 =	CamShakeConfig.AngleX_Max
			local aZ1 = CamShakeConfig.AngleZ_Min
			local aZ2 = CamShakeConfig.AngleZ_Max
			local aY1 = CamShakeConfig.AngleY_Min
			local aY2 = CamShakeConfig.AngleY_Max
			local s = 1

			if humanoid.Health == 0 or dead then
				s = 2
				aX1 = 2
				aX2 = 2

				aY1 = -3
				aY2 = 3

				aZ1 = -3
				aZ2 = 3

				DamageAmt = 1
			end

			local Recoil = CamShakeConfig.Recoil * daMulti * s
			--Recoil = Recoil * 0.02
			local CurrentRecoil = Recoil

			local RecoilX = math.rad(CurrentRecoil * RAND(aX1, aX2, CamShakeConfig.Accuracy))
			local RecoilY = math.rad(CurrentRecoil * RAND(aY1, aY2, CamShakeConfig.Accuracy))
			local RecoilZ = math.rad(CurrentRecoil * RAND(aZ1, aZ2, CamShakeConfig.Accuracy))

			if Character:FindFirstChild("HumanoidRootPart") then
				cameraspring:accelerate(Vector3.new(RecoilX, RecoilY, RecoilZ))
				coroutine.wrap(function()
					fastWait(0.03)
					cameraspring:accelerate(Vector3.new(-RecoilX, -RecoilY, 0))
				end)()
			end
		end


		local function Flashed(Part,Calc,Time,event)
			if not Part and Part.Parent then return end
			if not Player.Character then return end

			local humanoid = Player.Character:FindFirstChild("Humanoid")
			local head = Player.Character:FindFirstChild("Head")
			local hrp = Player.Character:FindFirstChild("HumanoidRootPart")

			--local x = mapList
			--table.insert(x,Part)

			local cam_center = Camera.ViewportSize / 2

			local function Check1()
				local vector, withinScreenBounds = Camera:WorldToScreenPoint(Part.Position)

				local point = Vector2.new(vector.X, vector.Y)
				local v = (point - cam_center).Magnitude

				return withinScreenBounds,v
			end

			local function Check2()
				local gPart,position

				local tempPart = Part:Clone()
				tempPart:ClearAllChildren()

				local b = Instance.new("BoolValue")
				b.Name = "CanHitT"
				b.Parent = tempPart

				tempPart.CFrame = Part.CFrame
				tempPart.CanTouch = true
				tempPart.Transparency = 0.99
				tempPart.Parent = workspace.Terrain
				table.insert(effectsList,tempPart)

				local attachments = {}
				local EXPERIMENTAL_HIT_DETECTION = true
				local BLAST_POSITION = tempPart.CFrame.Position

				if EXPERIMENTAL_HIT_DETECTION then
					local rad2 = 60 / 15

					table.insert(attachments,mz.ehdM.NewAttachment(tempPart,BLAST_POSITION,0,0,0,true))	

					if rad2 > 0.5 then
						table.insert(attachments,mz.ehdM.NewAttachment(tempPart,BLAST_POSITION,0,rad2,0))
						table.insert(attachments,mz.ehdM.NewAttachment(tempPart,BLAST_POSITION,0,-rad2,0))

						table.insert(attachments,mz.ehdM.NewAttachment(tempPart,BLAST_POSITION,rad2,0,0))
						table.insert(attachments,mz.ehdM.NewAttachment(tempPart,BLAST_POSITION,-rad2,0,0))

						table.insert(attachments,mz.ehdM.NewAttachment(tempPart,BLAST_POSITION,0,0,rad2))
						table.insert(attachments,mz.ehdM.NewAttachment(tempPart,BLAST_POSITION,0,0,-rad2))

						if rad2 / 2 > 0.5 then
							table.insert(attachments,mz.ehdM.NewAttachment(tempPart,BLAST_POSITION,0,rad2/2,0))
							table.insert(attachments,mz.ehdM.NewAttachment(tempPart,BLAST_POSITION,0,-rad2/2,0))
						end
					end
				end

				local tempHead = Instance.new("Part")
				tempHead.Name = "FHead2"
				tempHead.Size = Vector3.new(1.2,1,1)
				tempHead.CanCollide = false
				tempHead.CanTouch = false
				tempHead.Transparency = 1
				tempHead.CFrame = head.CFrame
				tempHead.Parent = head.Parent

				local raycastCheck = mz.ehdM:Cast(tempPart,attachments,tempHead,60 / 5,true,true,true)

				--local ray = Ray.new(Camera.CFrame.Position, (tempPart.Position - Camera.CFrame.Position).Unit * ((Part.CFrame.p - Camera.CFrame.Position).Magnitude + 1))
				--gPart, position = rayHandlerModule.CastRay(ray,{Player.Character;workspace.CurrentCamera},{type = "f"})

				tempPart:Destroy()
				tempHead:Destroy()

				return raycastCheck
			end

			blindCode = mRand()
			local cCode = blindCode

			--local t1_be1 = TS:Create(bE1,TweenInfo.new(0.15,Enum.EasingStyle.Quint,Enum.EasingDirection.Out),{Brightness = amt})
			--local t1_be2 = TS:Create(bE1,TweenInfo.new(0.25,Enum.EasingStyle.Quint,Enum.EasingDirection.In),{Brightness = 0})

			--spawn(function()
			--	t1_be1:Play()
			--	fastWait(0.3)
			--	if bE1 and bE1.Parent then
			--		t1_be2:Play()
			--	end
			--end)

			local onScreen,screenPointT = Check1()
			local canSee = Check2()

			if humanoid and humanoid.Parent then
				local hit = canSee and Calc >= 0.1

				local n = 1 - (screenPointT/cam_center.Magnitude)

				hit = hit and n > -0.1
				--and onScreen
				--and hrp.CFrame:toObjectSpace(Part.CFrame).p.Z<0

				local addRing = 0
				local blurMulti = 0.5
				if not hit then
					Time = 1
					addRing = Calc * 3
					blurMulti = 0.5;
				else
					Calc = Calc * n
				end

				local sound = scriptStuff.Flashbang:Clone()
				sound.Parent = scriptStuff.BlindSounds
				sound.Volume = 0

				local inf1 = TweenInfo.new(0.1,Enum.EasingStyle.Quint,Enum.EasingDirection.Out)

				local equ1 = Instance.new("EqualizerSoundEffect")
				equ1.Priority = 15
				equ1.HighGain = 0
				equ1.LowGain = 0
				equ1.MidGain = 0

				scriptStuff.FlashbangEffect:Clone();
				equ1.Parent = SoundService.Main
				local equ2 = equ1:Clone();equ2.Parent = SoundService.Radios

				table.insert(effectsList,equ1)
				table.insert(effectsList,equ2)

				Debris:AddItem(equ1,Time + 6)
				Debris:AddItem(equ2,Time + 6)

				local bE1 = Instance.new("ColorCorrectionEffect",Camera)
				bE1.Name = "BlindEffect"
				Debris:AddItem(bE1,1)
				local amt = ((Calc / 2) + 0.35) * 1

				table.insert(effectsList,bE1)

				local flashGUI = ReplicatedStorage.Storage.GUIs.FlashedGUI:Clone()
				local flashFrame = flashGUI:WaitForChild("Frame")
				table.insert(effectsList,flashGUI)
				flashGUI.Parent = Player.PlayerGui

				Debris:AddItem(flashFrame,Time + 5)

				local Anim

				if hit and not (sgS.CharF and sgS.CharF.Currents["NFLZXES"]) then
					if not DownedCheck() then
						Anim = humanoid:LoadAnimation(ReplicatedStorage.Storage.Animations.BlindAnim)
						Anim.Priority = Enum.AnimationPriority.Idle
						Anim:Play(0.1,(Calc /2) + 0.5,0.01)
					end

					--local slowDown = AffectChar("SD",Time + 2.5,"Blinded",6 * Calc)
					--local aJ = AffectChar("AJ",Time + 2.5)
					--local aS = AffectChar("AS",Time + 2.5)

					--local sD = AffectChar("SD",Time,math.random(),5)
				else
					--local sD = AffectChar("SD",Time,1,5)
				end

				local ndd = AffectChar("ND",60,"FL" .. math.random(),100)

				--humanoid.NameDisplayDistance = 0
				--humanoid.HealthDisplayDistance = 0

				local bE2 = Instance.new("ColorCorrectionEffect")
				bE2.Name = "BlindEffect"

				local bE2_5 = Instance.new("BlurEffect")
				bE2_5.Name = "BlindEffect"

				bE2.Brightness = 0
				bE2_5.Size = 0

				Debris:AddItem(bE2,Time + 5)
				Debris:AddItem(bE2_5,Time + 5)

				bE2.Parent = Camera
				bE2_5.Parent = Camera

				table.insert(effectsList,bE2)
				table.insert(effectsList,bE2_5)

				if canSee then
					TS:Create(bE2_5,inf1,{Size = 50 * Calc * blurMulti}):Play()
					TS:Create(bE2,inf1,{Contrast = 2 * Calc}):Play()

					TS:Create(flashFrame,inf1,{BackgroundTransparency = Lerp(-0.25,0.17,1 - Calc)}):Play()
				end

				sound:Play()
				TS:Create(sound,TweenInfo.new(1,Enum.EasingStyle.Quint,Enum.EasingDirection.Out),{Volume = 0.35 * Calc}):Play()
				TS:Create(equ1,inf1,{HighGain = -90 * Calc;MidGain = -90 * Calc; LowGain = -50 * Calc;}):Play()
				TS:Create(equ2,inf1,{HighGain = -90 * Calc;MidGain = -90 * Calc; LowGain = -50 * Calc;}):Play()

				local function StopFlash(doTime,fadeTime)
					local t = tick()
					repeat RunService.Heartbeat:Wait()
					until tick() - t >= doTime or not humanoid.Parent or humanoid.Health <= 0

					pcall(function()
						TS:Create(equ1,TweenInfo.new((fadeTime * 1.7) + addRing,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut),{HighGain = 0;LowGain = 0;MidGain = 0}):Play()
						TS:Create(equ2,TweenInfo.new((fadeTime * 1.7) + addRing,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut),{HighGain = 0;LowGain = 0;MidGain = 0}):Play()
						TS:Create(flashFrame,TweenInfo.new(fadeTime * 1,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut),{BackgroundTransparency = 1}):Play()
					end)

					if sound and sound.Parent then
						TS:Create(sound,TweenInfo.new((fadeTime * 2) + addRing,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{Volume = 0}):Play()
					end

					if Anim then
						Anim:Stop(fadeTime * 1.25)
					end

					--		if slowDown and slowDown.Parent then
					--			TS:Create(slowDown,TweenInfo.new(2.5,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{Value = 0}):Play()
					--		end

					if bE2 and bE2.Parent then
						TS:Create(bE2,TweenInfo.new(fadeTime,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut),{Brightness = 0;Contrast = 0}):Play()
					end

					if bE2_5 and bE2_5.Parent then
						TS:Create(bE2_5,TweenInfo.new((fadeTime * 1.5) + addRing,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut),{Size = 0}):Play()
					end

					if ndd and ndd.Parent then
						TS:Create(ndd,TweenInfo.new((fadeTime * 1.5),Enum.EasingStyle.Quad,Enum.EasingDirection.InOut),{Value = 0}):Play()
						task.delay(fadeTime,function()
							ndd:Destroy()
						end)
					end

					--pcall(function()
					--	TS:Create(Player.Character.Humanoid,TweenInfo.new(fadeTime * 1.25,Enum.EasingStyle.Quint,Enum.EasingDirection.In),{HealthDisplayDistance = game.StarterPlayer.HealthDisplayDistance;NameDisplayDistance = game.StarterPlayer.NameDisplayDistance}):Play()
					--end)

					Time,equ1,equ2,sound,Anim,bE2,bE2_5 = nil,nil,nil,nil,nil,nil,nil
				end

				--print(Time,Time * 0.2,Time * 0.8)

				coroutine.wrap(function()
					StopFlash(Time * 0.25,Time * 0.75)
				end)()

				if hit then
					return event:FireServer(true)
				else
					return false
				end
			end
			return false
		end

		local function ShellShock(Calc,Time,ShockMulti,sDAdd,noSD,soundMulti,depthMulti,sdMulti)
			if not Player.Character then return end
			ShockMulti = ShockMulti or 1
			soundMulti = soundMulti or 1
			depthMulti = depthMulti or 1
			sdMulti = sdMulti or 1

			--Time = Time + 2

			local ShockMulti2 = ShockMulti / 2
			ShockMulti2 = math.max(ShockMulti2,1)

			local humanoid = Player.Character:FindFirstChild("Humanoid")

			local function StopShock(Time,equ1,equ2,sound,slowDown,bE2_5,bE2_6)
				local t = tick()
				repeat RunService.Heartbeat:Wait()

				until tick() - t >= Time or not humanoid.Parent or humanoid.Health <= 0

				pcall(function()
					TS:Create(equ1,TweenInfo.new(1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut),{HighGain = 0;LowGain = 0;MidGain = 0}):Play()
					TS:Create(equ2,TweenInfo.new(1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut),{HighGain = 0;LowGain = 0;MidGain = 0}):Play()
				end)

				if sound and sound.Parent then
					TS:Create(sound,TweenInfo.new(1,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{Volume = 0}):Play()
				end

				if slowDown and slowDown.Parent then
					TS:Create(slowDown,TweenInfo.new(1,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{Value = 0}):Play()
				end

				if bE2_5 and bE2_5.Parent then
					TS:Create(bE2_5,TweenInfo.new(1,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{Size = 0}):Play()
				end	

				if bE2_6 and bE2_6.Parent then
					TS:Create(bE2_6,TweenInfo.new(1,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{
						FarIntensity = 0,
						FocusDistance = 0,
						InFocusRadius = 500,
						NearIntensity = 0,
					}
					):Play()
				end	

				--pcall(function()
				--	TS:Create(Player.Character.Humanoid,TweenInfo.new(1,Enum.EasingStyle.Quint,Enum.EasingDirection.In),{HealthDisplayDistance = game.StarterPlayer.HealthDisplayDistance;NameDisplayDistance = game.StarterPlayer.NameDisplayDistance}):Play()
				--end)

				Time,equ1,equ2,sound,slowDown,bE2_5 = nil,nil,nil,nil,nil,nil,nil
			end

			if humanoid and humanoid.Parent then
				local ndd = AffectChar("ND",Time,"SS" .. math.random(),30)

				local sound = scriptStuff.ShellShocks:GetChildren()[mRand(1,#scriptStuff.ShellShocks:GetChildren())]:Clone()
				sound.Parent = scriptStuff.BlindSounds
				sound.Volume = 0.55 * Calc * ShockMulti2
				sound:Play()

				local equ1 = scriptStuff.ShellShockEffect:Clone();equ1.Parent = SoundService.Main

				local hG = equ1.HighGain * Calc * ShockMulti * soundMulti
				local mG = equ1.HighGain * Calc * ShockMulti * soundMulti
				local lG = equ1.HighGain * Calc * soundMulti

				equ1.HighGain = 0
				equ1.MidGain = 0
				equ1.LowGain = 0

				table.insert(effectsList,equ1)
				local equ2 = equ1:Clone();equ2.Parent = SoundService.Radios
				table.insert(effectsList,equ2)
				Debris:AddItem(equ1,Time + 1)
				Debris:AddItem(equ2,Time + 1)	

				TS:Create(equ1,TweenInfo.new(1.5,Enum.EasingStyle.Quint,Enum.EasingDirection.Out),{HighGain = hG;MidGain = mG;LowGain = lG}):Play()
				TS:Create(equ2,TweenInfo.new(1.5,Enum.EasingStyle.Quint,Enum.EasingDirection.Out),{HighGain = hG;MidGain = mG;LowGain = lG}):Play()

				sDAdd = sDAdd or 0

				local slowDown,aJ,aS

				if not noSD then
					slowDown = AffectChar("SD",Time * sdMulti,"Shocked",(3 + sDAdd) * Calc)
					aJ = AffectChar("AJ",Time * sdMulti);Debris:AddItem(aJ,5)
					aS = AffectChar("AS",Time * sdMulti);Debris:AddItem(aJ,5)
				end

				humanoid.NameDisplayDistance = 0
				humanoid.HealthDisplayDistance = 0

				local bE2_5 = Instance.new("BlurEffect")

				local bE2_6 = Instance.new("DepthOfFieldEffect")
				bE2_6.FarIntensity = 0
				bE2_6.FocusDistance = 0
				bE2_6.InFocusRadius = 0
				bE2_6.NearIntensity = 0

				bE2_5.Name = "BlindEffect"
				bE2_6.Name = "BlindEffect"

				local size = 10 * Calc * ShockMulti

				local size2 = (20 - ((10 * Calc) * ShockMulti)) / depthMulti
				size2 = math.max(size2,0)

				bE2_5.Size = (size * 2.5)

				bE2_5.Parent = Camera
				bE2_6.Parent = Camera

				TS:Create(bE2_5,TweenInfo.new(Time / 1.5,Enum.EasingStyle.Linear,Enum.EasingDirection.In),{Size = size}):Play()
				TS:Create(bE2_6,TweenInfo.new(Time / 1.5,Enum.EasingStyle.Linear,Enum.EasingDirection.In),{FarIntensity = 1 * depthMulti;FocusDistance = 10;InFocusRadius = size2;NearIntensity = 1 * depthMulti}):Play()

				Debris:AddItem(bE2_5,Time + 3)
				Debris:AddItem(bE2_6,Time + 3)

				table.insert(effectsList,bE2_5)
				table.insert(effectsList,bE2_6)

				spawn(function()
					StopShock(Time,equ1,equ2,sound,slowDown,bE2_5,bE2_6)
				end)
			end
			return false
		end

		local function StunEffect(multi,length,fadeTime)
			local t = length - fadeTime
			local mds = _G.AffectChar("MS",math.huge,math.random(), multi)
			game.Debris:AddItem(mds,fadeTime + t)
			fastWait(t)
			if mds and mds.Parent then
				game.Debris:AddItem(mds,fadeTime)
				TS:Create(mds,TweenInfo.new(fadeTime,Enum.EasingStyle.Quart,Enum.EasingDirection.In),{Value = 1}):Play()
			end
		end

		local function StunGrenaded(Calc,Time)
			coroutine.wrap(function()
				ShellShock(Calc,Time,1.5,3)
			end)()

			local multi = Lerp(0.1,0.25,1 - Calc)

			StunEffect(multi,Time,1)
		end

		local function TearGas(tim)
			sgS.gasTime = tick()
			if sgS.gassed then return end
			sgS.gassed = true

			local ef = Instance.new("BlurEffect")
			ef.Name = "TEGA_Effect"
			ef.Parent = Camera
			ef.Size = 0

			local ndd = AffectChar("ND",math.huge,"TG" .. math.random(),15)

			table.insert(effectsList,ef)

			local t
			coroutine.wrap(function()
				repeat fastWait(0)
					pcall(function() t:Cancel() end)

					local siz = mRand(200,400) / 10

					t = TS:Create(ef,TweenInfo.new(0.2,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{Size = siz})
					t:Play()

					if sgS.CharF and sgS.CharF.Humanoid and not sgS.CharF.Humanoid:GetAttribute("NoGasStun") and S_Get() > 16 then
						S_Take(0.5)
					end
				until tick() - sgS.gasTime >= tim or not (ef and ef.Parent) or not sgS.gassed

				if ef and ef.Parent then
					pcall(function() t:Cancel() end)
					t = TS:Create(ef,TweenInfo.new(4,Enum.EasingStyle.Sine,Enum.EasingDirection.In),{Size = 0})
					t:Play()
					Debris:AddItem(ef,4)
				end
				sgS.gassed = false

				if ndd and ndd.Parent then
					ndd:Destroy()
				end
			end)()
		end

		local function MonitorExplosionSound(Sound,Time,Distance,Added,ShakeDiv,BrightDiv,ContrastDiv)
			if not ShakeDiv then ShakeDiv = 1 end
			if not BrightDiv then BrightDiv = 1 end

			local Do,err = pcall(function()
				local isAttachment = false
				if Sound and Sound.Parent then
					isAttachment = Sound.Parent:IsA("Attachment")

					if isAttachment or Sound.Parent:IsA("BasePart") then
						monitorSounds[Sound][7] = Sound.Parent
					end
				end

				local ExpPart = monitorSounds[Sound][7]

				if ExpPart ~= nil then
					local Pos = nil

					if sgS.CharF.Humanoid and sgS.CharF.Humanoid.Parent and sgS.CharF.Humanoid:GetState() ~= Enum.HumanoidStateType.Dead and sgS.CharF.Torso and sgS.CharF.Torso.Parent then		
						Pos = Player.Character.Torso.CFrame.Position
					else
						Pos = Camera.CFrame.Position
					end

					local distPos = (isAttachment and ExpPart.WorldPosition) or ExpPart.Position

					--Pos = Camera.CFrame.Position

					Distance = Distance or 1
					Distance = Distance / 3.5
					Distance = math.max(Distance,1)
					Added = Added or 1

					local MaxDist = (Sound.EmitterSize * Distance)
					local OriginalDist = (Pos - distPos).Magnitude

					local Dist1 = OriginalDist / MaxDist
					Dist1 = math.clamp(1 - Dist1, 0,1)

					local Dist2 = OriginalDist / MaxDist
					Dist2 = 1 - Dist2

					Dist1,Dist2 = math.max(Dist1,0),math.max(Dist2,0)

					sgS.Amt = sgS.Amt + (Sound.PlaybackLoudness * 0.0002 * Added) * Dist1 * BrightDiv-- Brightness
					sgS.Amt2 = sgS.Amt2 + (Sound.PlaybackLoudness * 0.02 * Added) * Dist2 * ShakeDiv -- Shake

					if ContrastDiv then
						sgS.Amt3 = sgS.Amt3 + (Sound.PlaybackLoudness * 0.0001 * Added) * Dist1 * ContrastDiv -- Shake
					end
				end
			end)
			if Do == false then
				--warn("Error with MonitorSounds",err)
			end
		end


		local function RUN_BIND1(dt)
			debug.profilebegin("RUN_BIND1-RenderStepped")
			sgS.Amt = 0
			sgS.Amt2 = 0
			sgS.Amt3 = 0

			if not gameLoaded then return end

			local brightV = sgS.TweenValue1.Value
			if brightV ~= sgS.TweenValue1_BN then
				sgS.TweenValue1_BN = brightV
				CC.Brightness = brightV
			end

			local contrastV = sgS.TweenValue3.Value
			if contrastV ~= sgS.TweenValue3_BN then
				sgS.TweenValue3_BN = contrastV
				CC.Contrast = contrastV
			end

			local vf = GVF()
			if vf and vf.Parent then
				local x = 70
				pcall(function()
					if _G.PVEye_FOV then
						Camera.FieldOfView = _G.PVEye_FOV
						sgS.FOV = _G.PVEye_FOV
					else
						for _,v in pairs(vf.FOVs:GetChildren()) do
							x = x + v.Value
						end

						if x ~= sgS.FOV then
							sgS.FOV = x
							Camera.FieldOfView = x
						end
					end
				end)
			end

			for _,v in pairs(monitorSounds) do
				MonitorExplosionSound(v[1],v[2],v[3],v[4],v[5],v[6],v[8])
			end

			if not _G.PVEye_Active then
				Camera.CFrame = Camera.CFrame * CFrame.Angles(0, 
					0, mRad(mRand(-sgS.TweenValue2.Value, 
						sgS.TweenValue2.Value) * 0.01)) + Vector3.new(
					mRad(mRand(-sgS.TweenValue2.Value, sgS.TweenValue2.Value)), 
					mRad(mRand(-sgS.TweenValue2.Value, sgS.TweenValue2.Value)), 
					mRad(mRand(-sgS.TweenValue2.Value, sgS.TweenValue2.Value))
				)
			end

			if Settings.CameraBobbing then
				local s,ms = S_Get()
				if gHum and gHum.Parent and gHum.Health > 0 and vf and vf.Parent and (gHum.MoveDirection:Dot(gHum.MoveDirection) > 0) or (s / ms < 0.5) then
					local nDistance,nSpeed = 0,0

					if gHum.MoveDirection:Dot(gHum.MoveDirection) > 0 then
						nDistance = nDistance + math.min(gHum.WalkSpeed,35) / 15
						nSpeed = nSpeed + math.min(gHum.WalkSpeed,45) / 2

						pcall(function()
							if vf.Crouching.Value then
								nDistance = nDistance * 1.5
							end
						end)

						if not _G.FP then
							nDistance = nDistance / 1.5
						end
					else
						local calc = Lerp(0,1,s/ms)
						calc = 1 - calc

						nDistance = nDistance + (calc * 0.5)
						nSpeed = nSpeed + (calc * 3)
					end

					--walkSmoothValue.Value = Vector3.new(walkSmoothValue.Value.X,nSpeed,nDistance)

					if nSpeed > 0 or nDistance > 0 then
						walkSmoothValue:Update(Vector3.new(1,nSpeed,nDistance))
					end
				else
					if walkSmoothValue.Value.Y > 0 or walkSmoothValue.Value.Z > 0 then
						walkSmoothValue:Update(Vector3.new(0,walkSmoothValue.Value.Y,walkSmoothValue.Value.Z))
					end
				end

				local speed = walkSmoothValue.Value.Y
				local distance = walkSmoothValue.Value.Z * walkSmoothValue.Value.X

				local rad = distance * (math.sin(customTick))


				local movementTing = CFrame.new()
				if sgS.CharF.Humanoid and sgS.CharF.Root and sgS.CharF.Humanoid.Parent and sgS.CharF.Root.Parent then
					movementTing = mz.vBob.Movement(dt,sgS.CharF.Humanoid,sgS.CharF.Root,sgS.vB_S.CamModX, sgS.vB_S.CamModY, sgS.vB_S.CamModZ, sgS.vB_S.CameraSpeedX, sgS.vB_S.CameraSpeedY, sgS.vB_S.CameraSpeedZ, sgS.vB_S.x, sgS.vB_S.y, sgS.vB_S.CamSpeed)
				end
				Camera.CoordinateFrame = Camera.CoordinateFrame  * movementTing
				--*CFrame.Angles(0,0,math.rad((distance*rad)))

				customTick = customTick + (dt * speed)

				local cf2 = CFrame.new()

				local camShakePart = _G.camShakePart
				if _G.FP 
					--and m_VF.Currents:FindFirstChild("FPHeadRot") 
					and sgS.CharF.State ~= Enum.HumanoidStateType.Swimming 
					and sgS.CharF.Humanoid
					and sgS.CharF.Humanoid.Health > 0 
					and sgS.CharF.Head
					and camShakePart
					and camShakePart.Parent
				then
					local cammotor = camShakePart:FindFirstChild("Motor6D")
					local transform 
					if cammotor and sgS.LastShakeTransform then
						local z1 = math.rad(camShakePart.Orientation.Z)
						local z2 = math.rad(sgS.CharF.Root.Orientation.Z)

						transform = cammotor.Transform
						transform = transform:Lerp(CFrame.new(),0.5)

						z1 *= 0.5

						cf2 = (transform * sgS.LastShakeTransform:Inverse()) * CFrame.Angles(0,0,z2 - z1)

					end

					sgS.LastShakeTransform = transform or cammotor.Transform

					_G.CamShakeCFrameOffset1 = cf2

					Camera.CoordinateFrame *= cf2
				else
					_G.CamShakeCFrameOffset1 = CFrame.new()
				end
			end

			if math.abs(cameraspring.p.x) > 0 or math.abs(cameraspring.p.y) > 0 or math.abs(cameraspring.p.z) > 0 then
				Camera.CoordinateFrame = Camera.CoordinateFrame*CFrame.Angles(cameraspring.p.x*dt*sgS.pfps,cameraspring.p.y*dt*sgS.pfps,cameraspring.p.z*dt*sgS.pfps)
			end

			local Day_Length = sgS.DayLength -- 15
			local Night_Length = sgS.NightLength -- 7.5

			local underGround1 = underGroundCheck(Camera.CFrame.Position,1)
			local underGround2 = underGroundCheck(Camera.CFrame.Position,2)

			local reverb = reverbType

			local currentTime = (serverTick.Value - startClockTick.Value) / 60 % (Day_Length + Night_Length);

			local t = 0
			if currentTime < Day_Length then
				t = 6 + 12 * currentTime / Day_Length
			else
				t = (18 + 12 * (currentTime - Day_Length) / Night_Length) % 24
			end

			if sgS.TimeState_Enabled then
				t = sgS.TimeState_Value
			end

			if t >= 23.9 or t <= 0.05 then
				timeSmoothValue.Value = Vector3.new(t,0,0)
			else
				timeSmoothValue:Update(Vector3.new(t,0,0))
			end

			reverbType = Settings.DefaultReverbType

			if not _G.NoSGReverbChange then
				if sgS.CharF.Char then
					local hum = sgS.CharF.Humanoid
					if hum.Health > 0 then
						if hum.Health > 15 and not DownedCheck() then
							if underGround2 then
								reverbType = Enum.ReverbType.SewerPipe
								reverbVolume = 0.5
								audioDir.CityAmbience.Playing = false
								audioDir.SewerAmbience.Playing = true
								audioDir.UndergroundAmbience.Playing = false
							elseif underGround1 then
								reverbVolume = 0.65
								reverbType = Enum.ReverbType.Quarry
								audioDir.CityAmbience.Playing = false
								audioDir.SewerAmbience.Playing = false
								audioDir.UndergroundAmbience.Playing = true
							else
								reverbVolume = 1
								reverbType = Settings.DefaultReverbType
								if sgS.LOutage then
									audioDir.CityAmbience.Playing = false
									audioDir.SewerAmbience.Playing = false
									audioDir.UndergroundAmbience.Playing = true
								else
									audioDir.CityAmbience.Playing = true
									audioDir.SewerAmbience.Playing = false
									audioDir.UndergroundAmbience.Playing = false
								end

							end
						else
							reverbVolume = 0.5
							reverbType = Enum.ReverbType.UnderWater
						end
					else
						reverbVolume = 0.5
						reverbType = Enum.ReverbType.UnderWater
					end
				end

				SoundService.AmbientReverb = reverbType
				sgS.sG.Volume = reverbVolume
			end

			local getNumber = function(clockTime)
				local maxDistance = 12 -- The furthest distance the clock will ever be away.
				local desiredTime = 12

				local distance = math.abs(desiredTime - clockTime) 
				local percentAway = distance/maxDistance -- Will give you 1 for 100% away and 0 for directly ontop of.
				local percent = math.abs(percentAway - 1) -- Reverts it around, giving you 1 for 0 and 0 for 1.

				return percent
			end

			local num = getNumber(game.Lighting.ClockTime)

			if _G.Y8OTOP then
				num = 0
			end

			--local ambientNum = Lerp(55,100,1 - num)

			--local outdoorAmbientNum1 = 120
			--local outdoorAmbientNum2 = 137
			--local outdoorAmbientNum3 = 157

			--local brightNum = Lerp(3,3,num)

			--local cloudCoverNum = Lerp(1,0.678,num)
			--local cloudDenseNum = Lerp(0.153,0.271,num)
			--local cloudColorNum = Lerp(15,254,num)

			--local AtmoNum1 = math.max(Lerp(-0.5,1,num),0)
			--local AtmoNum2 = math.max(Lerp(-0.5,1,num),0)
			--local AtmoNum3 = math.max(Lerp(-0.5,1,num),0)

			--local DecayNum1 = 1 --math.max(Lerp(1,1,num),0)
			--local DecayNum2 = 1 --math.max(Lerp(1,1,num),0)
			--local DecayNum3 = 1 --math.max(Lerp(1,1,num),0)

			----local hazeNum = math.max(Lerp(0,0,1 - num),0)
			--local hazeNum = math.max(Lerp(1,2.5,1 -num),0)

			--local denseNum = Lerp(0.02,0.25,1 - num)
			--local timeNum = timeSmoothValue.Value.X

			--AtmoNum1 = math.max(AtmoNum1,0.02)
			--AtmoNum2 = math.max(AtmoNum2,0.02)
			--AtmoNum3 = math.max(AtmoNum3,0.02)


			local ambient = sgS.LightingConfig.Night.Ambient:Lerp(sgS.LightingConfig.Day.Ambient,num)

			local outdoorAmbient = sgS.LightingConfig.Night.OutdoorAmbient:Lerp(sgS.LightingConfig.Day.OutdoorAmbient,num)

			local brightNum = Lerp(sgS.LightingConfig.Night.Brightness,sgS.LightingConfig.Day.Brightness,num)

			local ColorShift_Top

			if sgS.LightingConfig.Day.ColorShift_Top then
				ColorShift_Top = sgS.LightingConfig.Day.ColorShift_Top:Lerp(sgS.LightingConfig.Night.ColorShift_Top,1-(num/1))
			end

			--local cloudCoverNum = Lerp(1,0.678,num)
			--local cloudDenseNum = Lerp(0.153,0.271,num)
			--local cloudColorNum = Lerp(15,254,num)

			local AtmoNum1,AtmoNum2,AtmoNum3
			local DecayNum1,DecayNum2,DecayNum3

			if typeof(sgS.LightingConfig.Day.Atmo) == "Color3" then
				local c = sgS.LightingConfig.Day.Atmo:Lerp(sgS.LightingConfig.Night.Atmo,1-(num/1))

				AtmoNum1 = c.R
				AtmoNum2 = c.G
				AtmoNum3 = c.B
			else
				AtmoNum1 = math.max(Lerp(sgS.LightingConfig.Night.Atmo,sgS.LightingConfig.Day.Atmo,num),0)
				AtmoNum2 = AtmoNum1
				AtmoNum3 = AtmoNum1

				AtmoNum1 = math.max(AtmoNum1,sgS.LightingConfig.MinAtmo or 0.02)
				AtmoNum2 = math.max(AtmoNum2,sgS.LightingConfig.MinAtmo or 0.02)
				AtmoNum3 = math.max(AtmoNum3,sgS.LightingConfig.MinAtmo or 0.02)
			end

			if typeof(sgS.LightingConfig.Day.Decay) == "Color3" then
				local c = sgS.LightingConfig.Day.Decay:Lerp(sgS.LightingConfig.Night.Decay,1-(num/1))

				DecayNum1 = c.R
				DecayNum2 = c.G
				DecayNum3 = c.B
			else
				DecayNum1 = math.max(Lerp(sgS.LightingConfig.Night.Decay,sgS.LightingConfig.Day.Decay,num),0)
				DecayNum2 = DecayNum1
				DecayNum3 = DecayNum1
			end

			--local hazeNum = math.max(Lerp(0,0,1 - num),0)
			local hazeNum = math.max(Lerp(sgS.LightingConfig.Night.Haze,sgS.LightingConfig.Day.Haze,num),0)

			local denseNum = Lerp(sgS.LightingConfig.Night.Density,sgS.LightingConfig.Day.Density, num)
			local timeNum = timeSmoothValue.Value.X

			if underGround2 then
				ambient =  sgS.LightingConfig.underGround2.ambient or ambient
				denseNum = sgS.LightingConfig.underGround2.denseNum or denseNum
				hazeNum = sgS.LightingConfig.underGround2.hazeNum or hazeNum
				timeNum = sgS.LightingConfig.underGround2.timeNum or timeNum

				if typeof(sgS.LightingConfig.underGround2.atmo) == "Color3" then
					local c = sgS.LightingConfig.underGround2.atmo

					if c then
						AtmoNum1 = c.R
						AtmoNum2 = c.G
						AtmoNum3 = c.B
					end
				else
					AtmoNum1 = sgS.LightingConfig.underGround2.atmo or AtmoNum1
					AtmoNum2 = AtmoNum1
					AtmoNum3 = AtmoNum1
				end

				if typeof(sgS.LightingConfig.underGround2.Decay) == "Color3" then
					local c = sgS.LightingConfig.underGround2.decay

					if c then
						DecayNum1 = c.R
						DecayNum2 = c.G
						DecayNum3 = c.B
					end
				else
					DecayNum1 = sgS.LightingConfig.underGround2.atmo or DecayNum1
					DecayNum2 = DecayNum1
					DecayNum3 = DecayNum1
				end
			elseif underGround1 then
				ambient =  sgS.LightingConfig.underGround1.ambient or ambient
				denseNum = sgS.LightingConfig.underGround1.denseNum or denseNum
				hazeNum = sgS.LightingConfig.underGround1.hazeNum or hazeNum
				timeNum = sgS.LightingConfig.underGround1.timeNum or timeNum

				if typeof(sgS.LightingConfig.underGround1.atmo) == "Color3" then
					local c = sgS.LightingConfig.underGround1.atmo

					if c then
						AtmoNum1 = c.R
						AtmoNum2 = c.G
						AtmoNum3 = c.B
					end
				else
					AtmoNum1 = sgS.LightingConfig.underGround1.atmo or AtmoNum1
					AtmoNum2 = AtmoNum1
					AtmoNum3 = AtmoNum1
				end

				if typeof(sgS.LightingConfig.underGround1.decay) == "Color3" then
					local c = sgS.LightingConfig.underGround1.decay

					if c then
						DecayNum1 = c.R
						DecayNum2 = c.G
						DecayNum3 = c.B
					end
				else
					DecayNum1 = sgS.LightingConfig.underGround1.atmo or DecayNum1
					DecayNum2 = DecayNum1
					DecayNum3 = DecayNum1
				end
			end

			if sgS.UndergroundMains.Model then
				if underGround2 and sgS.UndergroundMains.Model then
					sgS.UndergroundMains.LGU = tick()
					if not sgS.UndergroundMains.Active then
						sgS.UndergroundMains.Active = true

						sgS.UndergroundMains.Model.Parent = workspace.Map.Parts
					end
				else
					if sgS.UndergroundMains.Active and tick() - sgS.UndergroundMains.LGU > 3 then
						sgS.UndergroundMains.Active = false

						sgS.UndergroundMains.Model.Parent = ReplicatedStorage
					end
				end
			end

			if sgS.SubwayMains.Model then
				if underGround1 and sgS.SubwayMains.Model then
					sgS.SubwayMains.LGU = tick()
					if not sgS.SubwayMains.Active then
						sgS.SubwayMains.Active = true

						sgS.SubwayMains.Model.Parent = workspace.Map.Parts
					end
				else
					if sgS.SubwayMains.Active and tick() - sgS.SubwayMains.LGU > 3 then
						sgS.SubwayMains.Active = false

						sgS.SubwayMains.Model.Parent = ReplicatedStorage
					end
				end
			end

			if sgS.SetFogValue and sgS.SetFogValue ~= 0 then
				denseNum = sgS.SetFogValue
			end

			denseNum = denseNum + sgS.FogAddValue

			if sgS.SetHazeValue and sgS.SetHazeValue ~= 0 then
				hazeNum = sgS.SetHazeValue
			end

			if mVF and mVF.Parent then
				if sgS.CharF.Currents["NFXOG"] then
					denseNum = 0
				end

				if sgS.CharF.Currents["NNNVG"] then
					ambient =  Color3.fromRGB(200,200,200)
					brightNum = 2

					AtmoNum1 = 0
					AtmoNum2 = 1
					AtmoNum3 = 0
				end

				if sgS.CharF.Currents["CC_DenseAdd"] then
					for i,v in pairs(sgS.CharF.Currents["CC_DenseAdd"]) do
						denseNum = denseNum + v.Value
					end
				end
			end

			if _G.Y8OTOP then
				ambient =  Color3.fromRGB(75,75,75)
				--outdoorAmbientNum = 75
				timeNum = 0
				denseNum = denseNum / 2
			else

				local aM = sgS.AmbientMulti
				local bM = sgS.BrightnessMulti

				if sgS.DeviceType == 3 then
					aM *= 1.5
					bM *= 1.5
				end

				ambient = Color3.new(ambient.R * aM,ambient.G * aM,ambient.B * aM)
				outdoorAmbient = Color3.new(outdoorAmbient.R * aM,outdoorAmbient.G * aM,outdoorAmbient.B * aM)
				brightNum = brightNum * bM
			end

			if gameLoaded then
				game.Lighting.Ambient = ambient
				game.Lighting.ClockTime = timeNum
				game.Lighting.OutdoorAmbient = outdoorAmbient
				game.Lighting.Brightness = brightNum

				if ColorShift_Top then
					game.Lighting.ColorShift_Top = ColorShift_Top
				end

				local atmo = game.Lighting:FindFirstChild("Atmosphere")
				--local cloud = workspace.Terrain:FindFirstChild("Clouds")
				if atmo then
					local AtmoNum = Color3.new(AtmoNum1,AtmoNum2,AtmoNum3)
					local DecayNum = Color3.new(DecayNum1,DecayNum2,DecayNum3)
					atmo.Color = AtmoNum
					atmo.Decay = DecayNum
					atmo.Density = denseNum
					atmo.Haze = hazeNum
				end

				--if cloud then
				--	local cloudNum = cloudColorNum * sgS.CloudColorMulti

				--	cloud.Color = Color3.fromRGB(cloudNum,cloudNum,cloudNum)
				--	cloud.Cover = cloudCoverNum
				--	cloud.Density = cloudDenseNum
				--end
			end

			debug.profileend()
		end		
		local function CleanUp()
			blindCode = 0
			scriptStuff.BlindSounds:ClearAllChildren()

			sgS.gassed = false
			sgS.gasTime = 0

			for _,v in pairs(effectsList) do
				Destroy(v)
			end
			for _,v in pairs(_G.EffectsList) do
				Destroy(v)
			end

			sgS.ll_Brk = false
			sgS.rl_Brk = false

			effectsList = {}
			_G.EffectsList = {}

			sgS.ACCL = nil

			sgS.M_CharStats = nil

			if _G.Y8OTOP and _G.GetUbra then
				require(_G.GetUbra).T(false)
			end
		end		

		local function CharAdded(character)	
			_G.IsAlive = false
			if not gameLoaded then repeat fastWait(0.15) until gameLoaded or character ~= Player.Character end

			if character ~= Player.Character then
				return	
			end

			sgS.DiedData = nil

			fastWait(0)

			local c2 = character

			Camera = workspace.CurrentCamera

			sgS.CoreGuiStates = {}

			Player:SetAttribute("IsBackpackEnabled",false)
			--SetCoreGuiEnabled(Enum.CoreGuiType.Backpack,false)
			SetCoreGuiEnabled(Enum.CoreGuiType.Chat,false)
			sgS.canSetChat = false

			shifting = false

			for _,v in pairs(ReplicatedStorage.Storage.GUIs.PlayerGui:GetChildren()) do
				v:Clone().Parent = Player.PlayerGui
			end

			--pcall(function()	RunService:UnbindFromRenderStep("FP_BIND") end)

			FP_BINDING = false
			Player.CameraMinZoomDistance = StarterPlayer.CameraMinZoomDistance

			UIS.MouseDeltaSensitivity = sgS.InitialSensitivity
			--_G.FP_BINDING = false

			if folderToClear and folderToClear.Parent then
				folderToClear:ClearAllChildren()
			end

			CleanUp()
			Mouse.TargetFilter = filter

			sgS.MouseDeltaSensitivity = UIS.MouseDeltaSensitivity

			currentTable = deepCopy(currentTableClone)

			CheckInputType(nil,true)

			Upt_S()

			pcall(function()
				deathCamTing:Cancel()
			end)

			currentTable.WS = 0

			sgS.BreathMode = false

			--if nCam then
			--	nCam:disconnect()
			--end
			--nCam = CamShakeMod.new(CamShakeConfig)

			sgS.effect3.Size = 0
			sgS.crouchCount = 0

			WaitForChar()

			if Player.Character ~= c2 or not (c2 and c2.Parent) or not Player.Character then
				return
			end

			Camera = workspace.CurrentCamera
			currentTable.WS = Settings.DefaultWalkSpeed

			local humanoid = character:WaitForChild("Humanoid")
			gHum = humanoid

			task.delay(0.5,function()
				if Player.Character == character and humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
					Player:SetAttribute("IsBackpackEnabled",true)
					--SetCoreGuiEnabled(Enum.CoreGuiType.Backpack,true)
					SetCoreGuiEnabled(Enum.CoreGuiType.Chat,sgS.chatEn)
					sgS.canSetChat = true
				end
			end)

			pcall(function()
				scriptStuff.Flatline:Stop()
				sgS.sG_Tween:Cancel()
				sgS.sG_Tween2:Cancel()
			end)

			local t = tick()

			repeat fastWait(0.1) until ( GVF and GVF() ~= nil) or tick() - t > 5 or Player.Character ~= c2
			if tick() - t > 5 or Player.Character ~= c2 or not GVF then return end
			for _,v in pairs(L_SCS) do
				v:Clone().Parent = Player.Backpack
			end

			local Values = GVF()
			mVF = Values

			local RagdollTime = Values:WaitForChild("RagdollTime")
			local RagdollSwitch = RagdollTime:WaitForChild("RagdollSwitch")
			local Root = character:WaitForChild("HumanoidRootPart")
			local Torso = character:WaitForChild("Torso")
			local Neck = Torso:FindFirstChild("Neck")
			local Head = character:WaitForChild("Head")
			local Sprinting = Values:WaitForChild("Sprinting")

			if sgS.CharF.CustomCC then
				sgS.CharF.CustomCC:Destroy()
			end
			sgS.CharF.CustomCC = Instance.new("ColorCorrectionEffect")
			sgS.CharF.CustomCC.Parent = Camera

			sgS.isCrouching = false

			sgS.CharF.Torso = Torso
			sgS.CharF.Root = Root
			sgS.CharF.Neck = Neck
			sgS.CharF.Head = Head
			sgS.CharF.Humanoid = humanoid
			sgS.CharF.Tool = nil
			sgS.CharF.Char = character
			pcall(function()
				sgS.CharF.LA  = character:WaitForChild("Left Arm",3)
				sgS.CharF.RA  = character:WaitForChild("Right Arm",3)
				sgS.CharF.LL  = character:WaitForChild("Left Leg",3)
				sgS.CharF.RL  = character:WaitForChild("Right Leg",3)
			end)

			sgS.CharF.State = humanoid:GetState()

			sgS.CharF.Currents = {}

			sgS.CharF.lastSlide = 0
			sgS.CharF.sliding = false

			sgS.CharF.sprinting = false
			sgS.CharF.sprintTick = 0

			local function FunnyCurrents(v)
				local name = v.Name

				if name ~= "AS" 
					and name ~= "AC" 
					and name ~= "B" 
					and name ~= "FORCEC" 
					and name ~= "CM" 
					and name ~= "NRG" 
					and name ~= "NNNVG" 
					and name ~= "NFXOG"
					and name ~= "CLMB_SD"
					and name ~= "CC_Saturation"
					and name ~= "CC_Contrast"
					and name ~= "CC_Brightness"
					and name ~= "CC_DenseAdd"
					and name ~= "CC_TintColor"
					and name ~= "ROTROOT"
					and name ~= "Reviving"

				then
					return
				end

				if not sgS.CharF.Currents[v.Name] then
					sgS.CharF.Currents[v.Name] = {}	
				end
				table.insert(sgS.CharF.Currents[v.Name],v)

				local corrections = {"CC_Saturation";"CC_Contrast";"CC_Brightness";"CC_TintColor"}

				if sgS.CharF.CustomCC and table.find(corrections,name) then
					sgS.CharF.CustomCC.Brightness = 0
					sgS.CharF.CustomCC.Contrast = 0
					sgS.CharF.CustomCC.Saturation = 0
					sgS.CharF.CustomCC.TintColor = Color3.new(1,1,1)

					if sgS.CharF.Currents["CC_Saturation"] then
						for i,v in pairs(sgS.CharF.Currents["CC_Saturation"]) do
							sgS.CharF.CustomCC.Saturation += v.Value
						end
					end
					if sgS.CharF.Currents["CC_Contrast"] then
						for i,v in pairs(sgS.CharF.Currents["CC_Contrast"]) do
							sgS.CharF.CustomCC.Contrast += v.Value
						end
					end
					if sgS.CharF.Currents["CC_Brightness"] then
						for i,v in pairs(sgS.CharF.Currents["CC_Brightness"]) do
							sgS.CharF.CustomCC.Brightness += v.Value
						end
					end
					if sgS.CharF.Currents["CC_TintColor"] then
						for i,v in pairs(sgS.CharF.Currents["CC_TintColor"]) do
							sgS.CharF.CustomCC.TintColor = v.Value
						end
					end
				end
			end

			sgS.M_CharStats = ReplicatedStorage.CharStats:WaitForChild(Player.Name,30)

			local _s,_e = pcall(function()
				if sgS.M_CharStats then
					for i,v in pairs(sgS.M_CharStats.Currents:GetChildren()) do
						FunnyCurrents(v)
					end
					sgS.M_CharStats.Currents.ChildAdded:Connect(function(v)
						FunnyCurrents(v)
					end)
					sgS.M_CharStats.Currents.ChildRemoved:Connect(function(v)

						if sgS.CharF.Currents[v.Name] then
							local n = table.find(sgS.CharF.Currents[v.Name],v)
							if n then
								table.remove(sgS.CharF.Currents[v.Name],n)
								if #sgS.CharF.Currents[v.Name] <=0 then
									sgS.CharF.Currents[v.Name] = nil
								end
							end

							if v.Name == "NRG" then
								RTR()
							end
						end
					end)
				end
			end)
			if not _s then
				warn(_e)
			end

			local climbTing = false
			local cGyro		
			local charRemoved = false

			local cTb = currentTable

			local lStamina = S_Get()

			local regening = false

			sgS.hH.Value = 0
			humanoid.HipHeight = 0

			local necc = Instance.new("Part")
			necc.CanTouch = false
			necc.Massless = true
			necc.Transparency = 1
			necc.Size = Vector3.new(0.05,1,0.05)
			necc.Locked = true
			local w = Instance.new("Weld")
			w.Part0 = Torso
			w.Part1 = necc
			w.C0 = w.C0 * CFrame.new(0,1.5,0)
			w.Parent = necc
			necc.Parent = Torso

			Head.CollisionGroupId = PhysicsService:GetCollisionGroupId("No-Collide5")
			Torso.CollisionGroupId = PhysicsService:GetCollisionGroupId("No-Collide5")
			necc.CollisionGroupId = Root.CollisionGroupId

			humanoid:MoveTo(Root.Position)

			if sgS.MobileControlsM then
				sgS.MobileControlsM.NewCharacterFunction()
			end


			--RagdollModule.Initilize(character)

			sgS.activeTurnEffect = TurnEffectModule.New(character,humanoid,Root,true)

			coroutine.wrap(function()
				FD.NC()
			end)()

			Destroy(sgS.mBodyRotGyro)
			sgS.mBodyRotGyro = Instance.new("BodyGyro")
			cTag(sgS.mBodyRotGyro,"BM")
			sgS.mBodyRotGyro.MaxTorque = Vector3.new(0,6000,0)
			sgS.mBodyRotGyro.P = 10000
			sgS.mBodyRotGyro.D = 100

			inWater = false

			Camera.CameraType = Enum.CameraType.Custom
			Camera.CameraSubject = humanoid

			Mouse.TargetFilter = character
			Mouse.TargetFilter = workspace:FindFirstChild("Filter")

			reverbType = Settings.DefaultReverbType
			reverbVolume = 1

			sgS.sG_Tween = TS:Create(
				sgS.eqA_1,
				TweenInfo.new(3,Enum.EasingStyle.Quint,Enum.EasingDirection.Out,0,false,0),
				{HighGain = 0;MidGain = 0;LowGain = 0}
			)
			sgS.sG_Tween2 = TS:Create(
				sgS.eqB_1,
				TweenInfo.new(3,Enum.EasingStyle.Quint,Enum.EasingDirection.Out,0,false,0),
				{HighGain = 0;MidGain = 0;LowGain = 0}
			)	

			task.delay(3,function()
				sgS.eqA_1.Enabled = false
				sgS.eqB_1.Enabled = false
			end)

			sgS.sG_Tween:Play()
			sgS.sG_Tween2:Play()

			sgS.effect1.TintColor = Color3.new(1,1,1)
			sgS.effect2.TintColor = Color3.new(1,1,1)

			sgS.sFOVv = Instance.new("NumberValue",Values.FOVs)
			sgS.sFOVv.Value = 0

			sgS.sprN.Value = 0
			sgS.hH.Value = 0

			sprintTweenOn = TS:Create(sgS.sprN,TweenInfo.new(1,Enum.EasingStyle.Quint,Enum.EasingDirection.Out),{Value = 1})
			sprintTweenOff = TS:Create(sgS.sprN,TweenInfo.new(1,Enum.EasingStyle.Quint,Enum.EasingDirection.Out),{Value = 0})

			dead = false
			dead2 = false
			hrp = Root
			isRagdolled = false
			ctrling = false
			shifting = false

			if deathGUI and deathGUI.Parent then
				deathGUI:WaitForChild("Frame").Visible = false
				--deathGUI:WaitForChild("Label").Visible = false
				--deathGUI.RespawnButton.Visible = false
				TS:Create(deathGUI:WaitForChild("BlackFrame"),TweenInfo.new(3,Enum.EasingStyle.Quint,Enum.EasingDirection.Out),{BackgroundTransparency = 1}):Play()
				task.delay(3,function()
					if not dead and not charRemoved then
						_G.deathGUI = nil
						deathGUI:Destroy()
					end
				end)
			end

			local Last = humanoid.Health

			ResetAllow(true)
			sgS.DiedData = nil

			local aliv = true
			local gcCode = mRand()

			local sCode = 0
			local con0,con1,con2,con3,con4,con4_5,con4_52,con5,con6,con7,con7_5,con8,con3_5,con4_53,con4_54,con4_55,con4_55_2,con6_1,con6_2,con9_1,con9_2,con9_3,con9_4,con9_5
			con6 = true
			con7 = true

			local JDB = 1
			local LJ = time()
			local downJumpDB = false
			_G.lastClimbTick = 0

			local l_brk_sd,r_brk_sd

			local bLegSD = AffectChar("SD",math.huge,mRand(),6)
			bLegSD.Parent = nil

			local downGui = ReplicatedStorage.Storage.GUIs.DownedGUI:Clone()
			table.insert(effectsList,downGui)
			downGui.Enabled = false
			downGui.Parent = Player.PlayerGui

			_G.IsAlive = true

			if _G.DeviceType ~= 2 then
				--EventsFolder2.ChangeMouseLock:Fire(false,nil,true)
			end

			local downAnim = humanoid:LoadAnimation(ReplicatedStorage.Storage.Animations.DownedHold)

			local function disconnect()
				if not aliv then return end
				aliv = false

				Disconnect(con1)
				Disconnect(con2)
				Disconnect(con3)
				Disconnect(con3_5)
				Disconnect(con4)
				Disconnect(con4_5)
				Disconnect(con4_52)
				Disconnect(con4_53)
				Disconnect(con4_54)
				Disconnect(con4_55)
				Disconnect(con4_55_2)
				Disconnect(con5)
				Disconnect(con0)
				Disconnect(con8)
				Disconnect(con6_1)
				Disconnect(con6_2)
				Disconnect(con7)
				Disconnect(con9_1)
				Disconnect(con9_2)
				Disconnect(con9_3)
				Disconnect(con9_4)
				Disconnect(con9_5)
				--Disconnect(con7_5)

				Destroy(l_brk_sd)
				Destroy(r_brk_sd)
				con6 = false
				con7 = false
				sCode = 0
			end

			local function C0Tweak(gTool,dt)
				debug.profilebegin("DoTweak")
				local CFNew, CFAng, CFtoObjectSpace = CFrame.new, CFrame.Angles, CFrame.new().toObjectSpace

				local cD
				local isCamSubject = false
				if Neck and Neck.Parent then
					cD = CFtoObjectSpace(Root.CFrame, Camera.CFrame).LookVector.Unit

					isCamSubject = Camera.CameraSubject.Parent == character
				end

				--sgS.MousePoint
				local mHit = sgS.MousePoint
				local mOrigin = Mouse.Origin.p
				local neckEnabled = not character:GetAttribute("NoNeckMovement")
				--not character:FindFirstChild("NoMoveeTing")

				local state = humanoid:GetState()
				if state == Enum.HumanoidStateType.Climbing or state == Enum.HumanoidStateType.Swimming then
					mHit = Vector3.new(mHit.X,math.max(Root.Position.Y + 7.5,mHit.Y),mHit.Z)
				end

				local armEnabled = (gTool and not gTool:GetAttribute("NoArmMovement"))

				local doSL = (not _G.FP and UIS.MouseBehavior == Enum.MouseBehavior.LockCenter) and armEnabled

				_G.YLookVecNUM = cD.Y

				DoTweak(character,mHit,mOrigin,cD,neckEnabled,armEnabled,isCamSubject,doSL,nil,dt)

				debug.profileend()
			end

			local snowPart = workspace.Filter:FindFirstChild("SnowPart")
			if not snowPart then
				snowPart = ReplicatedStorage.Storage.SnowPart:Clone()
				snowPart.Parent = workspace.Filter
			end

			spawn(function()
				while con6 do
					fastWait(0.5)

					local can = true
					if _G.GSettings and not _G.GSettings.PostFX then
						can = false
					end

					if can then
						local p = Head.Position 
						local p1 = p + Vector3.new(0,50,0)
						local p2 = p - Vector3.new(0,1,0)

						local ray = Ray.new(p1, (p2 - p1) * 55)
						local obj, pos, normal = workspace:FindPartOnRayWithWhitelist(ray, {workspace.Map.Parts,Head},true)

						snowPart.CFrame = CFrame.new(p + Vector3.new(0,100,0))	

						local can = pos.Y - p.Y <= 7
						snowPart.P.Enabled = can
					else
						snowPart.P.Enabled = false
					end
				end
			end)

			coroutine.wrap(function()
				local function alivCCC()
					return character and character.Parent and aliv and sgS.CharF.State ~= Enum.HumanoidStateType.Dead and Root and Root.Parent
				end



				while con6 do
					if not alivCCC() then
						break
					end
					--print(gcCode)

					if RagdollSwitch.Value and not randomls.__z then
						randomls.__z = true
					else
						while RagdollSwitch.Parent and not RagdollSwitch.Value and alivCCC() do
							local dt = RunService.Heartbeat:Wait()
							sgS.activeTurnEffect:Update(dt)
						end
						--RagdollSwitch.Changed:Wait()
					end	

					if not alivCCC() then
						break
					end

					local x = false

					if RagdollSwitch.Value then
						ctrling = false
						shifting = false

						sgS.activeTurnEffect:Stop()

						if Head and Head.Parent then
							local RX,RY,RZ = Head.CFrame:ToOrientation()
							fpSmoothValue.Value = Vector3.new(RX,RY,RZ)
						end

						--local gTool = character:FindFirstChildOfClass("Tool")
						humanoid:UnequipTools()

						while RagdollSwitch.Value == true and alivCCC() do
							isRagdolled = true
							--humanoid.AutoRotate = false
							humanoid.Jump = false

							Head.CollisionGroupId = PhysicsService:GetCollisionGroupId("No-Collide5")
							Torso.CollisionGroupId = PhysicsService:GetCollisionGroupId("No-Collide5")

							humanoid.CameraOffset = Vector3.new(0,0,0)

							--if _G.FP and not FP_BINDING then
							--	FP_BINDING = true
							--	_G.FP_BINDING = true
							--	print("BINDED")
							--	RunService:BindToRenderStep("FP_BIND",Enum.RenderPriority.Camera.Value - 12,FP_BIND)
							--end

							if not FP_BINDING then
								Player.CameraMinZoomDistance = 5
							end

							if (hrp and hrp.Parent) and (Values.Grabbed.Value) then
								for _,v in pairs(character:GetChildren()) do
									if v:IsA("BasePart") then
										v.Velocity = Vector3.new(math.min(v.Velocity.X,5),math.min(v.Velocity.Y,5),math.min(v.Velocity.Z,5))
									end
								end
							end

							--humanoid:UnequipTools()

							if not x then
								x = true
								humanoid:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics,false)
								humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming,false)
								humanoid:SetStateEnabled(Enum.HumanoidStateType.Running,false)				
								humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping,false)
								humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown,false)
								humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp,false)
								humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall,false)				
								humanoid:SetStateEnabled(Enum.HumanoidStateType.Landed,false)
								humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,true)	

								pcall(function()
									task.delay(0,function()
										Head.CollisionGroupId = PhysicsService:GetCollisionGroupId("No-Collide5")
										Torso.CollisionGroupId = PhysicsService:GetCollisionGroupId("No-Collide5")
										humanoid:UnequipTools()
									end)
								end)
							end
							humanoid:ChangeState(Enum.HumanoidStateType.Ragdoll)
							nv1.Value = 0
							humanoid.WalkSpeed = 0

							RunService.Heartbeat:Wait()
						end


						--pcall(function()	RunService:UnbindFromRenderStep("FP_BIND") end)
						--Camera.CameraType = Enum.CameraType.Custom

						FP_BINDING = false
						Player.CameraMinZoomDistance = StarterPlayer.CameraMinZoomDistance

						--task.delay(0.1,function()
						--	if gTool and gTool.Parent and not character:FindFirstChildOfClass("Tool") and humanoid.Health > 0 then
						--		humanoid:EquipTool(gTool)
						--	end	
						--end)					
					end


					isRagdolled = false

					if humanoid.Health > 0 then
						if humanoid and humanoid.Parent then
							--humanoid.AutoRotate = true
							humanoid.PlatformStand = false
							humanoid:SetStateEnabled(Enum.HumanoidStateType.RunningNoPhysics,true)
							humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming,true)
							humanoid:SetStateEnabled(Enum.HumanoidStateType.Running,true)				
							humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping,true)
							humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown,true)
							humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp,true)
							humanoid:SetStateEnabled(Enum.HumanoidStateType.Freefall,true)				
							humanoid:SetStateEnabled(Enum.HumanoidStateType.Landed,true)
							humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll,false)	
						end
						humanoid:ChangeState(Enum.HumanoidStateType.Running)
					end

					local downed = DownedCheck()
					if downed and humanoid.Health > 0 then
						sgS.hH.Value = -1
						sgS.downed = true
						humanoid.CameraOffset = Vector3.new(0,-2,0)
					end

					if hrp and hrp.Parent then
						--local x,y,z = hrp.CFrame:ToEulerAnglesYXZ()

						--local v = Vector3.new()

						--if downed then
						--	v = Vector3.new(0,1,0)
						--end

						--for i = 1,2 do
						--	coroutine.resume(coroutine.create(function()
						--		x = math.deg(x)
						--		if x > 0 then
						--			x = math.min(x,15)
						--		else
						--			x = math.max(x,-15)
						--		end
						--		x = math.rad(x)

						--		hrp.CFrame = CFrame.new(hrp.CFrame.p + v) * CFrame.Angles(0,y,z)
						--		RunService.Heartbeat:Wait()
						--	end))
						--end
					end

					--coroutine.wrap(function()
					--	fastWait(0)	
					--	if tool and gTool.Parent then
					--		local t = tick()

					--		local function c()
					--			return CheckIfCan(character) and tick() - t < 0.2 and gTool.Parent
					--		end
					--		repeat RunService.Heartbeat:Wait()

					--		until not aliv or not character.Parent or c() or tick() - t > 0.2
					--		if c() then
					--			humanoid:EquipTool(gTool)
					--		end
					--	end
					--end)()

					Head.CollisionGroupId = PhysicsService:GetCollisionGroupId("No-Collide5")
					Torso.CollisionGroupId = PhysicsService:GetCollisionGroupId("No-Collide5")
				end
			end)()

			coroutine.wrap(function()
				local sD = AffectChar("SD",math.huge,mRand(),5)

				local jP = AffectChar("JR",math.huge,mRand(),15)

				table.insert(effectsList,sD)
				table.insert(effectsList,jP)

				local lDmgT = 0
				local forceOBJ1 = ForceChar(Root,Vector3.new(0,-10,0))
				local forceOBJ2 = ForceChar(Root,Vector3.new(0,100,0))
				local forceOBJ3 = ForceChar(Root,Vector3.new(0,0,0))

				forceOBJ1.Parent = nil
				forceOBJ2.Parent = nil

				local drownV = AffectChar("Drowning",math.huge)
				local underwaterV = AffectChar("Underwater",math.huge)
				drownV.Parent,underwaterV.Parent = nil,nil

				sD.Parent = nil
				jP.Parent = nil
				--swimting
				while aliv and humanoid.Health > 0 and Head and Head.Parent do
					fastWait(0.15)

					debug.profilebegin("WaterDrownCheck")

					local cf1 = Torso.CFrame
					local cf2 = Head.CFrame + Head.CFrame.LookVector + Vector3.new(0,0.5,0)

					local inW,undW = waterCheckM(true,true,cf1,cf2)
					local isSwimming = sgS.CharF.State == Enum.HumanoidStateType.Swimming

					inWater = inW 

					if inW and not isSwimming and not humanoid:GetAttribute("N_WTR_SD") then
						sD.Parent = Values.Currents
						jP.Parent = Values.Currents
					else
						sD.Parent = nil
						jP.Parent = nil
					end

					local downed = DownedCheck()
					local ragdolled = RagdollCheck(character)

					forceOBJ1.Force = Vector3.new(0,(ragdolled and -50) or math.random(-400,-200),0)

					if (isSwimming and not ragdolled) or (downed and inWater) then
						forceOBJ1.Parent = Root
					else
						forceOBJ1.Parent = nil
					end

					if (downed and inWater) then
						forceOBJ2.Parent = Root


						if not RagdollCheck(character) then
							EventsFolder.__DFfDD:FireServer("-r__r2")
						end
					else
						forceOBJ2.Parent = nil
					end

					local pForce = Vector3.new()

					if undW then
						local n = 1

						if tick() - lDmgT < 0.3 then
							S_Take(n)
						end

						local cS = S_Get()
						if cS - n <= 0 and cS > 0 then
							lDmgT = tick()
						end

						underwaterV.Parent = Values.Currents

						if S_Get() <= 0 then
							drownV.Parent = Values.Currents
							local int = 0.5
							if tick() - lDmgT >=int then
								local dmg = 15 * int

								if downed or humanoid.Health <= 15 then
									dmg = 1 * int
									pForce = Vector3.new(0,100,0)
								elseif humanoid.Health - dmg <= 15 then
									dmg = humanoid.Health - 15

									Values.Downed.Value = true
								elseif humanoid.Health > 25 then
									Values.Downed.Value = false
								end

								if not character:FindFirstChildOfClass("ForceField") then
									local calc = humanoid.Health - dmg 
									if calc <= 1 then
										--dmg = 0 
									end
									humanoid.Health = humanoid.Health - dmg 
								end

								AffectChar("NRG",3)

								EventsFolder.TK_DGM:FireServer(dmg,"Drown")
								lDmgT = tick()
							end
						else
							lDmgT = tick()
							drownV.Parent = nil
						end
					else
						lDmgT = tick()
						drownV.Parent = nil
						underwaterV.Parent = nil
					end

					if inW then
						local currentDir = getWaterCurrent(Root,3)

						if (downed and inWater) or (not downed) then
							forceOBJ3.Force = currentDir + (pForce * 1.5)
							forceOBJ3.Parent = Root	
						else
							forceOBJ3.Force = Vector3.new()
						end
					else
						forceOBJ3.Parent = nil
					end	

					debug.profileend()					
				end

				drownV.Parent = nil
				underwaterV.Parent = nil
			end)()

			--coroutine.wrap(function()
			local function DoGyroS(dt)
				if not aliv then
					return
				end		

				--if game then return end --yeah

				local state = humanoid:GetState()
				local climbing = state == Enum.HumanoidStateType.Climbing

				--if climbing or humanoid:GetState() == Enum.HumanoidStateType.Freefall then

				if not RagdollCheck(character) then

					if state ~= Enum.HumanoidStateType.Swimming then
						if Head and Head.Parent then
							Head.CanCollide = false
						end
						if Torso and Torso.Parent then
							Torso.CanCollide = false
						end

						--	--if state == Enum.HumanoidStateType.Swimming then
						--	--if character:FindFirstChild("Right Arm") then
						--	--	character["Right Arm"].CanCollide = false
						--	--end
						--	--if character:FindFirstChild("Right Arm") then
						--	--	character["Left Arm"].CanCollide = false
						--	--end
						--	--if character:FindFirstChild("Right Arm") then
						--	--	character["Left Leg"].CanCollide = false
						--	--end
						--	--if character:FindFirstChild("Right Arm") then
						--	--	character["Right Leg"].CanCollide = false
						--	--end
						--	--if character:FindFirstChild("Right Arm") then
						--	--	character["Left Leg"].CanCollide = false
						--	--end
						--end	
						if hrp and hrp.Parent then
							hrp.CanCollide = true
						end
					end
				else
					if hrp and hrp.Parent then
						hrp.CanCollide = false
					end

					--local bweh = {"Head";"Left Arm";"Right Arm";"Left Leg";"Right Leg"}
					--for _,v in pairs(bweh) do
					--	local bweh2 = character:FindFirstChild(v)
					--	if bweh2 then
					--		bweh2.CanCollide = false
					--	end
					--end
				end

				if climbing then
					_G.lastClimbTick = tick()
					if not climbTing then
						climbTing = true
						--humanoid.AutoRotate = false

						--					cGyro = Instance.new("BodyGyro")
						--					cTag(cGyro,"BM")
						--					cGyro.MaxTorque = Vector3.new(10e10,10e10,10e10)
						--					cGyro.CFrame = Root.CFrame
						--					cGyro.D = 1
						--					cGyro.P = 10000
						--					cGyro.Parent = Torso
					end

					local SomeCFrame = Torso.CFrame
					local RX, RY, RZ = SomeCFrame:ToOrientation()
					RX,RY,RZ = math.floor(RX * 100) / 100,math.floor(RY * 100) / 100,math.floor(RZ * 100) / 100	
				elseif climbTing then
					--humanoid.AutoRotate = true
					climbTing = false

					if cGyro then
						Destroy(cGyro)
					end
					cGyro = nil
				end

				C0Tweak(sgS.CharF.Tool,dt)
			end
			--end)()


			local hCon
			hCon = RunService.Heartbeat:Connect(function(dt)
				debug.profilebegin("gyroHeartbeat")
				if not aliv then
					hCon:Disconnect()
					return
				else
					DoGyroS(dt)
				end
				debug.profileend()

			end)
			MClimbC0Func = DoGyroS

			--local function bLegCheck()
			--	if Values.HealthValues["Left Leg"].Broken.Value or Values.HealthValues["Right Leg"].Broken.Value then
			--		bLegSD.Parent = Values.Currents
			--	else
			--		bLegSD.Parent = nil
			--	end
			--end
			--con6_1 = Values.HealthValues["Left Leg"].Broken.Changed:Connect(bLegCheck)
			--con6_2 = Values.HealthValues["Right Leg"].Broken.Changed:Connect(bLegCheck)

			--con7_5 = RunService.RenderStepped:Connect(function(dt)
			--	if not RagdollSwitch.Value then
			--		--SmoothMovementM:Update(character,dt)
			--	end		
			--end)

			--	RagdollSwitch.Changed:Connect(function(v)
			--		if v then
			--			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack,false)
			--		elseif humanoid:GetState() ~= Enum.HumanoidStateType.Dead then
			--			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack,true)
			--		end
			--	end)

			con7 = Values.Downed.Changed:Connect(function(x)
				if x then
					ShellShock(1,1.5,0.25,0,true)
				end

				if humanoid.Health <= 0 then return end
				if x then

					if not Values.Handcuffed.Value then
						for _,v in pairs(humanoid:GetPlayingAnimationTracks()) do
							v:Stop(0.5)
						end
					end

					pcall(function() sgS.crouch_Tween:Pause() end)
					pcall(function()
						if crouchAnim then
							crouchAnim:Stop(0.175)
							crouchAnim:Destroy()
							crouchAnim = nil

							Values.Crouching.Value = false
						end
					end)

					if not RagdollCheck() then
						sgS.hH.Value = -1
						humanoid.CameraOffset = Vector3.new(0,-2,0)
					end

					local con1,con2,con3

					local holding = false
					local holding2 = false
					local resist = false
					local animPlaying = false
					local resistBusy = false

					sgS.MobileControlsM.DiedFunction()

					local ev = EventsFolder.DownResist

					local sd = AffectChar("SD",math.huge,math.random(),1000)
					sd.Parent = nil

					local function DoResist(m,v)
						if resistBusy then return end
						if LimbCheck(character,"Head","Broken",true) then return end

						resistBusy = true

						if CheckIfFlinching(character) or RagdollCheck(character) or LimbCheck(character,"Head","Broken",true) then
							resist = false
						end

						coroutine.wrap(function()
							if m ~= Values.Downed.Resisting.Value then
								local result = ev:InvokeServer(m)
								resist = (result and m) or false
							else
								resist = m
							end
						end)()

						resistBusy = false
					end

					local curDiv = _G.InputType

					local function DeviceCheck()
						curDiv = _G.InputType

						if _G.InputType == 3 then
							downGui.Frame.Visible = false
							downGui.MobileFrame.Visible = true
						elseif _G.InputType == 2 then
							downGui.Frame.Visible = true
							downGui.MobileFrame.Visible = false

							downGui.Frame.ButtonFrame.ButtonXBG.Visible = true
							downGui.Frame.ButtonFrame.X.Visible = true
							downGui.Frame.ButtonFrame.B.Visible = false
						else
							downGui.Frame.Visible = true
							downGui.MobileFrame.Visible = false

							downGui.Frame.ButtonFrame.ButtonXBG.Visible = false
							downGui.Frame.ButtonFrame.X.Visible = false
							downGui.Frame.ButtonFrame.B.Visible = true
						end
					end
					DeviceCheck()

					con1 = UIS.InputBegan:Connect(function(inp,busy)
						if busy then return end
						if inp.KeyCode == Enum.KeyCode.F or inp.KeyCode == Enum.KeyCode.ButtonX then
							holding = true
						elseif inp.KeyCode == Enum.KeyCode.B then
							--holding2 = true
						end
					end)
					con2 = UIS.InputEnded:Connect(function(inp)
						if inp.KeyCode == Enum.KeyCode.F or inp.KeyCode == Enum.KeyCode.ButtonX  then
							holding = false
						elseif inp.KeyCode == Enum.KeyCode.B then
							--holding2 = false
						end
					end)

					con3 = downGui.MobileFrame.TextButton.MouseButton1Down:Connect(function()
						holding = not holding

						downGui.MobileFrame.TextButton.BackgroundColor3 = holding and Color3.fromRGB(5, 80, 255) or Color3.fromRGB(90, 90, 90)
					end)

					while Player.Character == character and Values.Downed.Value and humanoid.Health > 0 do
						if Player.Character ~= character or not Values.Downed.Value or humanoid.Health <= 0 then
							break
						end

						if _G.InputType ~= curDiv then
							DeviceCheck()
						end

						if not RagdollCheck() then
							if hrp and hrp.Parent then
								local x,y,z = hrp.CFrame:ToEulerAnglesYXZ()

								x = math.deg(x)
								if x > 0 then
									x = math.min(x,15)
								else
									x = math.max(x,-15)
								end
								x = math.rad(x)

								hrp.CFrame = CFrame.new(hrp.CFrame.p) * CFrame.Angles(0,y,z)
							end

							local can = (humanoid.MoveDirection.Magnitude <=0.1 or resist) and not LimbCheck(character,"Head","Broken",true) and not CheckIfFlinching()

							if holding and can and not sgS.CharF.Currents["Reviving"] then
								if not resist then
									DoResist(true)
								else
									if downGui and downGui.Parent then
										downGui.Enabled = _G.InputType == 3
									end
								end
							else
								if downGui and downGui.Parent then
									downGui.Enabled = can and not holding and not sgS.CharF.Currents["Reviving"] and not mVF.Grabbed.Value
								end							
								if resist then
									DoResist(false)
								end
							end
						else
							if resist then
								if downGui and downGui.Parent then
									downGui.Enabled = false
								end
								DoResist(false)
							end
						end

						if resist and not animPlaying then
							animPlaying = true
							downAnim:Play(0.2)
							sd.Parent = mVF.Currents
						elseif animPlaying and not resist then
							animPlaying = false
							downAnim:Stop(0.2)
							sd.Parent = nil
						end

						RunService.Heartbeat:Wait()
					end

					if downGui and downGui.Parent then
						downGui.Enabled = false
					end
					Disconnect(con1)
					Disconnect(con2)
					Disconnect(con3)

					Destroy(sd)

					sgS.MobileControlsM.NewCharacterFunction()

					downAnim:Stop()
				else
					sgS.hH.Value = 0
					humanoid.CameraOffset = Vector3.new(0,0,0)
				end
			end)

			local function RageMode_On(v)
				if randomls.raging then return end
				randomls.raging = true

				randomls.rage_fov = Instance.new("NumberValue")
				randomls.rage_fov.Parent = Values.FOVs

				local i = TweenInfo.new(3,Enum.EasingStyle.Quint,Enum.EasingDirection.Out)
				TS:Create(randomls.rage_fov,i,{Value = 30}):Play()	

				randomls.rage_color = Instance.new("ColorCorrectionEffect")
				randomls.rage_color2 = Instance.new("ColorCorrectionEffect")

				table.insert(effectsList,randomls.rage_color)
				table.insert(effectsList,randomls.rage_color2)

				randomls.rage_color.Parent = Camera
				randomls.rage_color2.Parent = Camera

				local tintColor = Color3.fromRGB(255, 143, 143)

				if v and v.Parent then
					local customColor = v:GetAttribute("CustomColor")
					if customColor then
						tintColor = sgS.ColorHueAdjuster(tintColor,customColor)
					end
				end


				TS:Create(randomls.rage_color,i,{Brightness = 0.1;Contrast = 0.2;Saturation = -0.25;TintColor = tintColor}):Play()
				randomls.rage_t = TS:Create(randomls.rage_color2,TweenInfo.new(0.25,Enum.EasingStyle.Linear,Enum.EasingDirection.Out,30,true),{Brightness = 0.1})
				randomls.rage_t:Play()
			end
			local function RageMode_Off()
				if not randomls.raging then return end
				randomls.raging = false

				local i = TweenInfo.new(1,Enum.EasingStyle.Linear,Enum.EasingDirection.Out)

				TS:Create(randomls.rage_fov,i,{Value = 0}):Play()
				TS:Create(randomls.rage_color,i,{Brightness = 0;Contrast = 0;Saturation = 0;TintColor = Color3.fromRGB(255, 255,255)}):Play()

				if randomls.rage_t then
					randomls.rage_t:Cancel()
				end
				randomls.rage_t = nil

				TS:Create(randomls.rage_color2,i,{Brightness = 0;Contrast = 0;Saturation = 0;TintColor = Color3.fromRGB(255, 255,255)}):Play()

				Debris:AddItem(randomls.rage_fov,1)
				Debris:AddItem(randomls.rage_color,1)
				Debris:AddItem(randomls.rage_color2,1)
			end


			local function Poison_On(poisV,frost,flame)
				if randomls.poisoned then return end
				if dead then return end
				if not poisV then return end

				randomls.poisoned = true

				randomls.poison_fov = Instance.new("NumberValue")
				randomls.poison_fov.Parent = Values.FOVs

				local i = TweenInfo.new(3,Enum.EasingStyle.Quint,Enum.EasingDirection.Out)

				randomls.poison_effect = Instance.new("ColorCorrectionEffect")
				randomls.poison_effect2 = Instance.new("BlurEffect")
				randomls.poison_effect2.Size = 0

				table.insert(effectsList,randomls.poison_effect)
				table.insert(effectsList,randomls.poison_effect2)

				randomls.poison_effect.Parent = Camera
				randomls.poison_effect2.Parent = Camera

				local tintColor =  (frost and Color3.fromRGB(134, 185, 255)) or (flame and Color3.fromRGB(255, 143, 121)) or Color3.fromRGB(183, 255, 134)

				local customColor = poisV and poisV:GetAttribute("CustomColor")
				if customColor then
					tintColor = sgS.ColorHueAdjuster(tintColor,customColor)
				end

				local PCONFIG = {
					Brightness = 0.85;
					Contrast = 2.1;
					Saturation = -0.35;
					TintColor = tintColor;

					BlurSize = 12;
					Fov = -35;
				}

				local c

				local function updt()
					local v = poisV.Value

					if humanoid.Health <= 0 then c:Disconnect() return end

					local t = {
						Brightness = PCONFIG.Brightness * v;
						Contrast = PCONFIG.Contrast * v;
						Saturation = PCONFIG.Saturation * v;
						TintColor = Color3.fromRGB(255,255,255):Lerp(PCONFIG.TintColor,(v/1));
					}
					TS:Create(randomls.poison_effect,i,t):Play()
					TS:Create(randomls.poison_effect2,i,{Size = PCONFIG.BlurSize * v}):Play()
					TS:Create(randomls.poison_fov,i,{Value = PCONFIG.Fov * v}):Play()
				end

				updt()	
				c = poisV.Changed:Connect(updt)
			end
			local function Poison_Off()
				if not randomls.poisoned then return end
				randomls.poisoned = false

				local i = TweenInfo.new(3,Enum.EasingStyle.Linear,Enum.EasingDirection.In)

				local t = {
					Brightness = 0;
					Contrast = 0;
					Saturation = 0;
					TintColor = Color3.fromRGB(255,255,255);
				}
				TS:Create(randomls.poison_effect,i,t):Play()
				TS:Create(randomls.poison_effect2,i,{Size = 0}):Play()
				TS:Create(randomls.poison_fov,i,{Value = 0}):Play()

				game.Debris:AddItem(randomls.poison_effect,4)
				game.Debris:AddItem(randomls.poison_effect2,4)
				game.Debris:AddItem(randomls.poison_fov,4)
			end

			local function Smoke_On()
				if dead then return end
				if randomls.smokesc then return end
				randomls.smokesc = true

				local gui = ReplicatedStorage.Storage.GUIs.SmokeScreenGUI:Clone()
				randomls.smokesc_gui = gui
				table.insert(effectsList,gui)
				gui.Parent = Player.PlayerGui

				local function z(v)
					TS:Create(v,TweenInfo.new(1,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{ImageTransparency = 0}):Play()
				end
				for _,v in pairs(gui:GetChildren()) do
					if v:IsA("ImageLabel") then
						z(v)
					end
				end
			end

			local function Smoke_Off()
				if not randomls.smokesc then return end

				randomls.smokesc = false

				if randomls.smokesc_gui and randomls.smokesc_gui.Parent then
					local function z(v)
						TS:Create(v,TweenInfo.new(1,Enum.EasingStyle.Linear,Enum.EasingDirection.In),{ImageTransparency = 1}):Play()
					end
					game.Debris:AddItem(randomls.smokesc_gui,1)
					for _,v in pairs(randomls.smokesc_gui:GetChildren()) do
						if v:IsA("ImageLabel") then
							z(v)
						end
					end
				end
			end

			local function DeathF()
				local t = tick()
				if dead then return end

				dead = true

				SetCoreGuiEnabled(Enum.CoreGuiType.Chat,false,3)
				sgS.canSetChat = false

				pcall(function()	RunService:UnbindFromRenderStep("FP_BIND") end)
				FP_BINDING = false
				_G.FP_BINDING = false
				Camera.CameraType = Enum.CameraType.Custom
				RunService.RenderStepped:Wait()

				sgS.hH.Value = 0
				humanoid.HipHeight = 0
				humanoid.CameraOffset = Vector3.new(0,0,0)
				humanoid.NameDisplayDistance = 0
				humanoid.HealthDisplayDistance = 0

				pcall(function()
					Player.PlayerGui.CoreGUI.XboxDropThing.Visible = false
				end)

				RageMode_Off()
				Poison_Off()
				sgS.activeTurnEffect:Stop()

				--SetCharPhysicalPropertiesModule(character,0.8)

				pcall(function()
					scriptStuff.Boom:Play()
					scriptStuff.Flatline:Play()
					if character:FindFirstChild("Head") and character:FindFirstChild("Torso") then
						scriptStuff.Flatline.TimePosition = 1.5
					end
					for i, track in pairs (humanoid:GetPlayingAnimationTracks()) do
						track:Stop(0.5)
					end
				end)

				--Camera.CameraType = Enum.CameraType.Watch
				local x = (character:FindFirstChild("Head") and character.Head.Transparency <= 0.95 and character["Head"]) or character:FindFirstChild("Torso")
				if x then
					Camera.CameraSubject = x
				end

				reverbType = Enum.ReverbType.Bathroom
				reverbVolume = 0.5

				if not _G.NoDeathEFZ then
					sgS.effect2.Enabled = true
					sgS.effect5.Enabled = true


					sgS.eqA_1.Enabled = true
					sgS.eqB_1.Enabled = true

					sgS.effect2.Saturation = -0.5
					sgS.effect5.Size = 15
				else
					sgS.effect2.Enabled = false
					sgS.effect5.Enabled = false

					sgS.eqA_1.Enabled = false
					sgS.eqB_1.Enabled = false
				end

				local CT = tick()

				local T1_E1 = TS:Create(
					sgS.effect2,
					TweenInfo.new(6,Enum.EasingStyle.Sine,Enum.EasingDirection.In),
					{Contrast = 0.5;Brightness = -0.25;} --b -1
				)
				--local T1_E2 = TS:Create(
				--	sgS.effect2,
				--	TweenInfo.new(1.5,Enum.EasingStyle.Quint,Enum.EasingDirection.Out,0,false,2),
				--	{Brightness = -0;Contrast = 0} -- b -1.75
				--)
				local T1_E3 = TS:Create(
					sgS.effect5,
					TweenInfo.new(6,Enum.EasingStyle.Sine,Enum.EasingDirection.In,0,false,0),
					{Size = 30}
				)


				sgS.sG_Tween = TS:Create(
					sgS.eqA_1,
					TweenInfo.new(5,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false,0),
					{HighGain = -80;MidGain = -80;LowGain = -80}
				)
				sgS.sG_Tween2 = TS:Create(
					sgS.eqB_1,
					TweenInfo.new(5,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false,0),
					{HighGain = -80;MidGain = -80;LowGain = -80}
				)		

				sgS.sG_Tween:Play()
				sgS.sG_Tween2:Play()

				local T2_E1 = TS:Create(
					sgS.effect2,
					TweenInfo.new(3,Enum.EasingStyle.Quint,Enum.EasingDirection.Out,0,false,0),
					{Contrast = 0; Saturation = 0;Brightness = 0}
				)
				--local T2_E2 = TS:Create(
				--	sgS.effect2,
				--	TweenInfo.new(3,Enum.EasingStyle.Quint,Enum.EasingDirection.Out,0,false,0),
				--	{Brightness = 0;Contrast = 0}
				--)
				local T2_E3 = TS:Create(
					sgS.effect5,
					TweenInfo.new(3,Enum.EasingStyle.Quint,Enum.EasingDirection.Out,0,false,0),
					{Size = 0}
				)

				--T1_E2:Play()
				T1_E1:Play()
				T1_E3:Play()
				sgS.sG_Tween:Play()
				sgS.sG_Tween2:Play()

				if sgS.MobileControlsM then
					sgS.MobileControlsM.DiedFunction()
				end

				spawn(function()
					fastWait(2.5)
					if Player.character == character then
						fastWait(2.5)
						if Player.character == character then
							humanoid.NameDisplayDistance = 0
							humanoid.HealthDisplayDistance = 0
						end
					end
				end)

				if deathGUI then
					deathGUI:Destroy()
				end
				deathGUI = scriptStuff.DeathGUI:Clone()
				_G.deathGUI = deathGUI
 
				local function DeathUI()
					if charRemoved then return end

					deathGUI.Parent = Player.PlayerGui

					_G.deathGUI = deathGUI

					local dG_F = deathGUI:WaitForChild("Frame")
					local dG_F2 = dG_F:WaitForChild("Frame2")
					local dG_R = dG_F:WaitForChild("ReportFrame")
					local dG_R2 = dG_F:WaitForChild("ReportFrame2")
					local dG_R3 = dG_F:WaitForChild("ReportFrame3")

					local label = dG_F:WaitForChild("Label")
					local g = label:WaitForChild("UIGradient")

					local i1 = TweenInfo.new(3,Enum.EasingStyle.Quart,Enum.EasingDirection.Out,0,false,3)
					local i1_5 = TweenInfo.new(7,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false,2.3)
					local i2 = TweenInfo.new(1,Enum.EasingStyle.Quad,Enum.EasingDirection.In)

					if Player:GetAttribute("NoRespawnUI") then
						label.Visible = false
					else
						TS:Create(label,i1,{TextTransparency = 0;TextStrokeTransparency = 0.5}):Play()
						TS:Create(label,TweenInfo.new(1.7,Enum.EasingStyle.Quint,Enum.EasingDirection.In,0,false,2.3) ,{Position = UDim2.new(0.5,0,0.5,-75)}):Play()
						--delay(4,function()
						--	if label and label.Parent and not charRemoved then
						--		T
						--	end
						--end)
					end

					local bfT_1 = TS:Create(deathGUI.BlackFrame,i1,{BackgroundTransparency = 0.3})
					bfT_1:Play()

					TS:Create(g,i1_5,{Offset = Vector2.new(1,0)}):Play()

					local busy = false
					local cons = {}
					local function DDisconnect()
						for _,v in pairs(cons) do
							if v then
								v:Disconnect()
							end
						end
					end

					for _,v in pairs(deathGUI:GetDescendants()) do
						if v:IsA("TextButton") then
							table.insert(cons,v.MouseEnter:Connect(function()
								if v.Selectable then
									uiSounds.hover:Play()
								end
							end))
							table.insert(cons,v.MouseButton1Down:Connect(function()
								if v.Selectable then
									uiSounds.click:Play()
								end
							end))
						end
					end

					local function OnPlay()
						if busy then return end

						if Player:GetAttribute("RespawningPaused") or ReplicatedStorage.Values.RespawningDisabled.Value then
							busy = true
							dG_F2.RespawnButton.Selectable = false
							dG_F2.RespawnButton.Active = false
							dG_F2.RespawnButton.Text = "Paused"	

							repeat
								task.wait(0.35)
							until not ReplicatedStorage.Values.RespawningDisabled.Value and not Player:GetAttribute("RespawningPaused")

							busy = false
							dG_F2.RespawnButton.Selectable = true
							dG_F2.RespawnButton.Active = true	

							if Player.Character ~= character and Player.Character and Player.Character.Parent then
								return
							end
						end
						local e = EventsFolder.DeathRespawn:InvokeServer("KMG4R904")

						if e and g and g.Parent then
							busy = true
							DDisconnect()

							dG_F2.RespawnButton.Selectable = false
							dG_F2.RespawnButton.Active = false
							dG_F2.RespawnButton.Text = "Respawning"		

							if bfT_1 then
								bfT_1:Cancel()
							end
							local bfT_2 = TS:Create(deathGUI.BlackFrame,i2,{BackgroundTransparency = 0})
							bfT_2:Play()							


							TS:Create(dG_F2.RespawnButton,TweenInfo.new(0.5,Enum.EasingStyle.Quart,Enum.EasingDirection.Out,0,true),{BackgroundColor3 = Color3.new(1,1,1)}):Play()
							task.delay(1,function()
								if dG_F2.Parent then
									dG_F2.RespawnButton.Visible = false
								end
							end)
							--				g.Offset = Vector2.new(0,-1)
							--				g.Rotation = -90
							--				TS:Create(g,i2,{Offset = Vector2.new(0,0)}):Play()

							local lz = {
								label;dG_F2.RespawnButton;dG_F2.ReportButton;dG_F2.Distance;dG_F2.DistanceTitle;dG_F2.Killer;dG_F2.KillerTitle;dG_F2.Weapon;dG_F2.WeaponTitle;dG_F2.ReportButton;dG_F2.MenuButton
							}

							for i,v in pairs(lz) do
								local g = {TextTransparency = 1;TextStrokeTransparency = 1}

								if v == dG_F2.ReportButton or v == dG_F2.MenuButton  then
									g.BackgroundTransparency = 1
								end

								TS:Create(v,i2,g):Play()
							end
							dG_F2.SettingsButton.BackgroundTransparency = 1
							TS:Create(dG_F2.SettingsButton,i2,{ImageTransparency = 1}):Play()
						end	
					end

					local function HandleReportS()
						local reportMode = 0
						local MAX_LENGTH = 50
						local busy = false
						local submitted = false
						local canReport = sgS.DiedData and sgS.DiedData.canReport ~= nil

						local description = nil

						local reportInfoLimit = true	

						local function UpdateCanReport()
							if (not canReport) or submitted then
								dG_F2.ReportButton.TextTransparency = 0.5
								dG_F2.ReportButton.BackgroundTransparency = 0.75
								dG_F2.ReportButton.Selectable = false
							else
								dG_F2.ReportButton.TextTransparency = 0
								dG_F2.ReportButton.BackgroundTransparency = 0.5
								dG_F2.ReportButton.Selectable = true
							end
						end

						local function OpenReport()
							if not canReport or submitted then return end

							dG_F2.Visible = false
							label.Visible = false
							dG_R.Visible = true
						end

						local function CancelReport1()
							if busy then return end

							dG_F2.Visible = true
							label.Visible = true
							dG_R.Visible = false
							dG_R2.Visible = false
							dG_R3.Visible = false

							dG_R.SuspectButton.Text = ""
							dG_R.AbuseButton.Text = ""
							dG_R.InfoBox.Text = ""
						end

						local function CancelReport2()
							if busy then return end

							UpdateCanReport()
							dG_R2.Visible = false
							dG_R.Visible = true
							dG_R3.Visible = false
						end

						local function SubmitReport1()
							if not reportInfoLimit then return end

							dG_R2.Visible = true
							dG_R.Visible = false
						end

						local function EndReport(success,id)
							if not reportInfoLimit then return end

							dG_R2.Visible = false
							dG_R.Visible = false
							dG_F2.Visible = false

							if success then
								uiSounds.BEEP:Play()

								dG_R3.TextBox.Visible = true
								dG_R3.Size = UDim2.new(0,300,0,170)
								dG_R3.Desc.Text = "Your report has been submitted.\n\nFor a faster response or if you have more info to provide, create a ticket in our Communications Server giving the ID below:"
								dG_R3.Desc.TextColor3 = Color3.fromRGB(120, 185, 122)	

								dG_R3.TextBox.Text = id

								dG_R3.TextBox:GetPropertyChangedSignal("Text"):Connect(function()
									dG_R3.TextBox.Text = id
								end)
								warn("Report submitted: " .. id)
							else
								uiSounds.error:Play()

								dG_R3.TextBox.Visible = false
								dG_R3.Size = UDim2.new(0,200,0,90)
								dG_R3.Desc.Text = "Error processing report"
								dG_R3.Desc.TextColor3 = Color3.fromRGB(185, 112, 112)

								warn("Report failed to submit")
							end

							UpdateCanReport()

							dG_R3.Visible = true
						end

						local function SubmitReportFull()
							if busy or not reportInfoLimit then return end
							busy = true
							local result = EventsFolder.FL_IGRBR:InvokeServer(nil,reportMode,dG_R.InfoBox.Text)
							submitted = true
							busy = false

							if result then
								EndReport(true,result)
							else
								EndReport(false)
							end						
						end

						local function InfoChanged()
							local len = string.len(dG_R.InfoBox.Text)
							local can1 = len <= MAX_LENGTH
							local can2 = (reportMode == 1 or reportMode == 2)

							reportInfoLimit = can1 and can2

							dG_R.InfoBox.TextLabel.Text = len .. "/" .. MAX_LENGTH
							dG_R.InfoBox.TextLabel.TextColor3 = (can1 and Color3.fromRGB(148, 148, 148)) or Color3.fromRGB(148, 0, 0)
							dG_R.InfoBox.TextColor3 = (can1 and Color3.fromRGB(255,255,255)) or Color3.fromRGB(255, 0, 0)

							dG_R.SubmitButton.BackgroundTransparency = 0.5 and reportInfoLimit or 0.75
							dG_R.SubmitButton.TextTransparency = 0 and reportInfoLimit or 0.5

							dG_R.SubmitButton.Selectable = reportInfoLimit
						end

						local function SetReportMode(m)
							if m == 1 then
								dG_R.SuspectButton.Text = ""
								dG_R.AbuseButton.Text = ""
							else
								dG_R.SuspectButton.Text = ""
								dG_R.AbuseButton.Text = ""
							end
							reportMode = m

							InfoChanged()
						end

						local function OpenSettings()
							dG_F.Visible = false
							EventsFolder2.ToggleSettingsUI:Fire(true)
						end

						table.insert(cons,dG_F2.ReportButton.MouseButton1Down:Connect(OpenReport))

						table.insert(cons,dG_F2.MenuButton.MouseButton1Down:Connect(function()
							EventsFolder2.ToggleReturnMenu:Fire()
						end))
						table.insert(cons,dG_F2.SettingsButton.MouseButton1Down:Connect(OpenSettings))
						table.insert(cons,EventsFolder2.SettingsClosed.Event:Connect(function()
							dG_F.Visible = true
						end))

						table.insert(cons,dG_R.SuspectButton.MouseButton1Down:Connect(function()
							SetReportMode(1)
						end))
						table.insert(cons,dG_R.AbuseButton.MouseButton1Down:Connect(function()
							SetReportMode(2)
						end))
						table.insert(cons,dG_R.InfoBox:GetPropertyChangedSignal("Text"):Connect(InfoChanged))


						table.insert(cons,dG_R.CancelButton.MouseButton1Down:Connect(CancelReport1))
						table.insert(cons,dG_R.SubmitButton.MouseButton1Down:Connect(SubmitReport1))
						table.insert(cons,dG_R2.CancelButton.MouseButton1Down:Connect(CancelReport2))
						table.insert(cons,dG_R2.SubmitButton.MouseButton1Down:Connect(SubmitReportFull))
						table.insert(cons,dG_R3.CancelButton.MouseButton1Down:Connect(CancelReport1))
						InfoChanged()
						CancelReport1()
						UpdateCanReport()
					end

					task.delay(4,function()
						if not sgS.DiedData then
							for i = 1,10 do
								if sgS.DiedData or charRemoved then
									break
								end
								task.wait(1)
							end
						end

						if not Player:GetAttribute("NoRespawnUI") and deathGUI and deathGUI.Parent and not (charRemoved and Player.Character) then

							local killerName = sgS.DiedData and sgS.DiedData.KillerName
							local distance = sgS.DiedData and sgS.DiedData.KillDistance
							local weapon = sgS.DiedData and sgS.DiedData.WeaponName

							dG_F2.Killer.Text = killerName or "N/A"
							dG_F2.Distance.Text = distance or "N/A"
							dG_F2.Weapon.Text = weapon or "N/A"
							dG_F2.Weapon.Text = string.upper(dG_F2.Weapon.Text)

							HandleReportS()

							dG_F2.Visible = true

							dG_F2.RespawnButton.Visible = true
							dG_F2.RespawnButton.TextSize = 20
							dG_F2.RespawnButton.Selectable = false
							dG_F2.RespawnButton.Active = false
							dG_F2.RespawnButton.Text = "Respawn in: " .. "0s"

							local t = 5

							--for i = 1,t * 10 do
							--	fastWait(0.1)
							--	t = t - 0.1
							--	if not (deathGUI and deathGUI.Parent) or charRemoved then
							--		break
							--	end
							--	local x =  tostring(math.floor(t * 10) / 10)
							--	if string.len(x) == 1 then
							--		x = x .. ".0"
							--	end
							--	dG_F2.RespawnButton.Text = "Respawn in: " .. x .. "s"
							--end

							if not (deathGUI and deathGUI.Parent) or charRemoved then
								return
							end

							dG_F2.RespawnButton.Active = true
							dG_F2.RespawnButton.Selectable = true

							if _G.InputType == 1 then
								dG_F2.RespawnButton.Text = "Respawn [E]"
							elseif _G.InputType == 2 then
								dG_F2.RespawnButton.Text = "Respawn " .. '<font color="rgb(255,165,0)">[Y]</font>'
							else
								dG_F2.RespawnButton.Text = "Respawn"
							end

							dG_F2.RespawnButton.TextSize = 25
							table.insert(cons,dG_F2.RespawnButton.MouseButton1Down:Connect(OnPlay))

							table.insert(cons,UIS.InputBegan:Connect(function(key,busy)
								if busy then return end
								if not dG_F2.Visible then return end
								if key.KeyCode == Enum.KeyCode.E or key.KeyCode == Enum.KeyCode.ButtonY then
									OnPlay()
								end
							end))
							table.insert(cons,Player.CharacterAdded:Connect(DDisconnect))
						end
					end)
				end

				spawn(DeathUI)

				Camera.CameraType = Enum.CameraType.Scriptable

				local xddd = Instance.new("NumberValue",Values.FOVs)
				xddd.Value = 0
				TS:Create(xddd,TweenInfo.new(7,Enum.EasingStyle.Elastic,Enum.EasingDirection.Out),{Value = 15}):Play()

				local v  = Instance.new("NumberValue")
				TS:Create(v,TweenInfo.new(7,Enum.EasingStyle.Quad,Enum.EasingDirection.In),{Value = 15}):Play()
				Debris:AddItem(v)

				local part = Instance.new("Part")
				part.CanCollide = false
				part.CanTouch = false
				part.Transparency = 1
				part.CFrame = Camera.CFrame
				part.Parent = character
				local bG = Instance.new("BodyGyro")
				bG.MaxTorque = Vector3.new(1000,1000,1000)
				bG.CFrame = Camera.CFrame
				bG.Parent = part
				local bP = Instance.new("BodyPosition")
				bP.MaxForce = Vector3.new(10000, 10000, 10000)
				bP.Position = Camera.CFrame.p
				bP.Parent = part

				table.insert(effectsList,part)

				local start = Camera.CFrame.p

				local t = tick()
				repeat RunService.Heartbeat:Wait()
					if not _G.NoDeathEFZ and Root and Root.Parent then
						pcall(function() deathCamTing:Cancel() end)

						local mag = (start - Root.CFrame.p).Magnitude
						if mag > 15 then	
							local ray = Ray.new(start, (Head.Position - start).Unit * (mag / 4))
							local _, position = workspace:FindPartOnRayWithWhitelist(ray, {})	
							start = position
						end

						local ray = Ray.new(start, ((start + Vector3.new(0,v.Value,0)) - start).Unit * (v.Value + 1))
						local _, position = workspace:FindPartOnRayWithWhitelist(ray, {map})
						position = position - Vector3.new(0,2,0)

						bG.CFrame = CFrame.new(Camera.CFrame.p,Root.Position)
						bP.Position = position

						deathCamTing = TS:Create(Camera,TweenInfo.new(0.05,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{CFrame = part.CFrame})
						deathCamTing:Play()	

						_G.DeathEFZ_deathCamTing = deathCamTing
					end
				until (charRemoved and not dead)
				--or tick() - t > 10

				_G.DeathEFZ_deathCamTing = nil

				if Player.Character == character then
					--if not Player:HasAppearanceLoaded() then
					--	Player.CharacterAppearanceLoaded:Wait()
					--end
					WaitForChar()
				end

				T1_E1:Pause()
				--T1_E2:Pause()
				T1_E3:Pause()
				T2_E1:Play()
				--T2_E2:Play()
				T2_E3:Play()		
			end

			local climbTing1
			con1 = humanoid.StateChanged:Connect(function(old,new)
				sgS.CharF.State = new

				if new == Enum.HumanoidStateType.FallingDown or new == Enum.HumanoidStateType.GettingUp then
					humanoid:ChangeState(Enum.HumanoidStateType.Running)
				end

				if new == Enum.HumanoidStateType.Climbing then
					local samt = 8.5
					local amt = samt
					local clamp = 1 - (humanoid.Health / humanoid.MaxHealth)
					clamp = math.clamp(clamp,0,amt)
					amt = amt + clamp
					amt = amt - samt
					amt = amt * samt

					if sgS.CharF.Currents["CLMB_SD"] then
						for i,v in pairs(sgS.CharF.Currents["CLMB_SD"]) do
							amt -= v.Value
						end
					end

					climbTing1 = AffectChar("SD",math.huge,mRand(),amt)
					--climbTing2 = AffectChar("AJ",math.huge)
				elseif old == Enum.HumanoidStateType.Climbing then
					Destroy(climbTing1)
				end
			end)

			con2 = humanoid.Changed:Connect(function(prop)
				if prop and prop == "Jump" then
					local currenttime = time()
					local jDB = JDB

					local needed = 10
					local amt = needed

					local state = humanoid:GetState()

					if humanoid.Health <= 0 or state == Enum.HumanoidStateType.Dead then return end

					if state == Enum.HumanoidStateType.Swimming then
						needed = 0
						jDB = 0.25
					end

					if Values.Crouching.Value or (LJ + JDB > currenttime) or sgS.CharF.Currents["AJ"] or CheckIfFlinching() then
						humanoid.Jump = false
					else
						if not RagdollCheck() and S_Get() >= needed then
							local amt2 = amt
							if state == Enum.HumanoidStateType.Swimming then
								--local RX,RY,RZ  = Root.CFrame:ToOrientation()
								--Root.CFrame = (CFrame.new(Root.CFrame.p) * CFrame.Angles(math.rad(0),RY,math.rad(0))) + Vector3.new(0,2.5,0)

								local cf = CFrame.new(Torso.Position + (Torso.CFrame.UpVector * 4))
								local inW = waterCheckM(true,false,cf,nil)

								--print(inW)
								if inW then
									amt2 = 0
								end

								humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming,false)
								task.delay(0.5,function()
									humanoid:SetStateEnabled(Enum.HumanoidStateType.Swimming,true)
								end)						
							end
							S_Take(amt2)
						elseif S_Get() >= 45 and not downJumpDB and DownedCheck() and RagdollCheck() and not GVF().Grabbed.Value then
							downJumpDB = true
							S_Take(55)
							humanoid.Jump = false
							ForceChar(Player.character.HumanoidRootPart,(Root.CFrame.UpVector + Vector3.new(0,1.85,0)) * GetModelMassModule(character) * 150,0.1)				
							task.delay(0.5,function()
								downJumpDB = false
							end)	
						else
							humanoid.Jump = false
							CantS()
						end
						LJ = currenttime
					end
				end
			end)

			con3 = humanoid.HealthChanged:Connect(function(h)
				if Last - h > 0.05 and (Last - h > 0.45 or h == 0 or sgS.CharF.Currents["Bleeding"] or sgS.CharF.Currents["Bleeding2"]) then

					local DamageAmt = (Last - h)
					if DamageAmt < 1 and Values.Downed.Resisting.Value then
						--bruh	
					else

						--			local HitSound = scriptStuff.Hit:Clone()
						--			HitSound.Parent = script
						--			
						--			HitSound.Pitch = HitSound.Pitch - (DamageAmt / 40)
						--			HitSound.Pitch = HitSound.Pitch * (mRand(-850,850) / 1000)
						--			HitSound:Play()
						--			Debris:AddItem(HitSound,3)

						DamageHitEffect(character,DamageAmt)
					end
				end
				Last = h

				if h <= 0 and character.Parent then
					sgS.hH.Value = 0
					humanoid.HipHeight = 0
					humanoid.CameraOffset = Vector3.new(0,0,0)
					DeathF()
				end
			end)

			con3_5 = humanoid.Running:Connect(function(s)
			end)

			con8 = character.ChildAdded:Connect(function(t)
				if t.ClassName == "Tool" then
					local zz = false

					if _G.InputType ~= 2 then
						AffectChar("B",0.15)
					end

					if _G.InputType == 3 or _G.InputType == 2 then
						zz = t:GetAttribute("canDrop")

						sgS.MobileControlsM.EnableButton("drop_item",zz)

						if zz then
							local _c 
							RunService.Heartbeat:Wait()
							if t and t.Parent then
								_c = t.AncestryChanged:Connect(function(_,parent)
									_c:Disconnect()
									RunService.Heartbeat:Wait()
									local z = character 
										and character.Parent 
										and sgS.CharF.Tool
										and sgS.CharF.Tool:GetAttribute("canDrop")

									sgS.MobileControlsM.EnableButton("drop_item",
										z
									)

									--if _G.InputType == 2 then
									pcall(function()
										Player.PlayerGui.CoreGUI.XboxDropThing.Visible = _G.InputType == 2 and z
									end)
									--end
								end)
							end

							if _G.InputType == 2 then
								pcall(function()
									Player.PlayerGui.CoreGUI.XboxDropThing.Visible = true
								end)

							end
						else
							pcall(function()
								Player.PlayerGui.CoreGUI.XboxDropThing.Visible = false
							end)

						end
					else
						pcall(function()
							Player.PlayerGui.CoreGUI.XboxDropThing.Visible = false
						end)
					end
				end
				--bruh this sucks 
			end)

			local function updateLimbs()
				--if LimbCheck(character,"Left Leg","Broken") then
				if Values.HealthValues["Left Leg"].Broken.Value then
					sgS.ll_Brk = true
					local lb = Values.HealthValues["Left Leg"].Destroyed.Value
					if not l_brk_sd and not lb then
						l_brk_sd = AffectChar("SP",math.huge,math.random(),0.84)
					elseif l_brk_sd and lb then
						Destroy(l_brk_sd)
						l_brk_sd = nil
					end
				else
					sgS.ll_Brk = false
					Destroy(l_brk_sd)
					l_brk_sd = nil
				end
				--if LimbCheck(character,"Right Leg","Broken") then
				if Values.HealthValues["Right Leg"].Broken.Value then
					sgS.rl_Brk = true
					local lb = Values.HealthValues["Right Leg"].Destroyed.Value
					if not r_brk_sd and not lb then
						r_brk_sd = AffectChar("SP",math.huge,math.random(),0.84)
					elseif r_brk_sd and lb then
						Destroy(r_brk_sd)
						r_brk_sd = nil
					end
				else
					sgS.rl_Brk = false
					Destroy(r_brk_sd)
					r_brk_sd = nil
				end
			end
			updateLimbs()

			con9_1 = Values.HealthValues["Left Leg"].Broken.Changed:Connect(updateLimbs)
			con9_2 = Values.HealthValues["Right Leg"].Broken.Changed:Connect(updateLimbs)
			con9_3 = Values.HealthValues["Left Leg"].Destroyed.Changed:Connect(updateLimbs)
			con9_4 = Values.HealthValues["Right Leg"].Destroyed.Changed:Connect(updateLimbs)
			con9_5 = EventsFolder.OHNRGEE.OnClientEvent:Connect(updateLimbs)

			local function RSF(hsr)
				regening = true
				while regening and aliv and not sgS.CharF.Currents["NRG"] do 
					fastWait(0.04)
					debug.profilebegin("RSF regen")

					local s,ms = S_Get()
					if s >= ms then break end

					local amt = -0.6
					if DownedCheck() or RagdollCheck() or Values.Grabbing.Value then 
						amt = amt / 2.5 
					end

					if s + (-amt) > 100 then
						amt = -(100 - s)
					end

					if hsr then
						amt = amt * 1.5
					end

					lStamina = S_Take(amt)

					debug.profileend()
				end
				regening = false
			end

			local function SPRFunc()
				coroutine.wrap(function()
					while aliv do 
						fastWait(0.04)
						debug.profilebegin("SPRFunc")

						--print(gcCode)

						local s,ms = S_Get()

						if s <=0 or not Sprinting.Value or RagdollSwitch.Value then break end

						local amt  = 0.25

						if Values.Grabbing.Value then
							amt = amt * 1.35	
						end
						local zm = humanoid:GetAttribute("ZSPRN_M")
						if zm then
							amt *= zm
						end

						local clamp = 1 - (humanoid.Health / humanoid.MaxHealth)
						clamp = math.clamp(clamp,0,amt * 0.55)
						amt = amt + clamp

						--				if s - amt <= 0 then
						--					amt = s - amt
						--				end

						S_Take(amt)

						debug.profileend()
					end
					SprintTing(false)
					Sprinting.Value = false
				end)()
			end

			RTR = function()
				local v,mv = S_Get()

				--print(v < lStamina, v < mv, not regening,not Values.Currents:FindFirstChild("NRG"))

				if (v < lStamina or (v < mv and not regening)) and not sgS.CharF.Currents["NRG"] then
					local cCode = mRand()
					sCode = cCode
					regening = false

					lStamina = v

					coroutine.wrap(function()
						local hsr = HSRGEE(Player.Character)
						local n = 0.05 and Values and hsr or 1.25
						fastWait(n)
						if sCode == cCode and not regening and (hsr or not sgS.CharF.Currents["NRG"]) then
							sCode = mRand()
							RSF(hsr)
						end
					end)()
				end

				local v,mv = S_Get()
				lStamina = v
			end

			con4 = staminaSignal:GetPropertyChangedSignal("Value"):Connect(RTR)

			local function ACCL_DO(v)
				sgS.ACCL = {}

				sgS.ACCL.SD = AffectChar("SD",math.huge,"ACCLD",0)
				sgS.ACCL.V = v
				sgS.ACCL.M = v:WaitForChild("M").Value
				sgS.ACCL.R = v.Value
			end

			local function nC(v)
				if v.Name == "NRG" then
					sCode = mRand()
					regening = false
				elseif v.Name == "RMMM" then
					RageMode_On(v)
				elseif v.Name == "POIZSKRATA" then
					Poison_On(v)
				elseif v.Name == "FROSTSKRATA" then
					Poison_On(v,true)
				elseif v.Name == "FLAMESKRATA" then
					Poison_On(v,nil,true)
				elseif v.Name == "SMMKE" then
					Smoke_On()
				elseif v.Name == "ACCLTRR" then
					ACCL_DO(v)
				end
			end

			con4_5 = Values.Currents.ChildAdded:Connect(nC)
			for _,v in pairs(Values.Currents:GetChildren()) do 
				nC(v)
			end

			con4_52 = Values.Currents.ChildRemoved:Connect(function(v)
				if v.Name == "NRG" then
					RTR()
				elseif v.Name == "RMMM" then
					RageMode_Off()
				elseif v.Name == "POIZSKRATA" then
					Poison_Off(v)
				elseif v.Name == "FROSTSKRATA" then
					Poison_Off(v,true)
				elseif v.Name == "FLAMESKRATA" then
					Poison_Off(v,nil,true)
				elseif v.Name == "SMMKE" then
					RunService.Heartbeat:Wait()
					if not sgS.CharF.Currents["SMMKE"] then
						Smoke_Off()
					end
				elseif v.Name == "ACCLTRR" and not sgS.CharF.Currents["ACCLTRR"] then
					if sgS.ACCL and sgS.ACCL.SD then
						Destroy(sgS.ACCL.SD)
					end
					sgS.ACCL = nil
				end
			end)

			con4_55 = character.ChildRemoved:Connect(function(v)
				if v:IsA("Tool") then
					for _,z in pairs(v:GetDescendants()) do
						if z:IsA("BasePart") then
							z.LocalTransparencyModifier = 0
						end
					end

					RunService.RenderStepped:Wait()

					sgS.CharF.Tool = character:FindFirstChildOfClass("Tool")
				end
			end)

			con4_55_2 = character.ChildAdded:Connect(function(v)
				if v:IsA("Tool") then
					sgS.CharF.Tool = v

					if sgS.CharF.toolCon then
						sgS.CharF.toolCon:Disconnect()
					end
					sgS.CharF.toolCon = v.AncestryChanged:Connect(function(_,parent)
						sgS.CharF.toolCon:Disconnect()
						sgS.CharF.toolCon = nil
						sgS.CharF.Tool = character and character.Parent and character:FindFirstChildOfClass("Tool")
					end)
				end
			end)

			local function combatTing()
				EventsFolder2.InCombat:Fire(InCombatCheck(Player,true))
			end

			con4_53 = Values.Tags.ChildAdded:Connect(combatTing)
			con4_54 = Values.Tags.ChildRemoved:Connect(combatTing)

			con5 = Sprinting:GetPropertyChangedSignal("Value"):Connect(function(v)
				if Sprinting.Value then
					SPRFunc()
				end
			end)

			con0 = character.AncestryChanged:Connect(function(_,parent)
				if not parent then
					charRemoved = true
					disconnect()
				end
			end)
		end

		local function SetUp()
			--	ReplicatedStorage:WaitForChild("CharStats").ChildAdded:Connect(function(v)
			--		if v.Name ~= Player.Name then
			--			v:Destroy()
			--		end
			--	end)
			--	
			--	for _,v in pairs(ReplicatedStorage.CharStats:GetChildren()) do
			--		if v.Name ~= Player.Name then
			--			v:Destroy()
			--		end
			--	end

			currentTable = deepCopy(currentTableClone)

			_G.GSFFLDR = ReplicatedStorage.Storage.SouffleDir
			_G.GSFFLDR.Name = ""
			_G.GSFFLDR.Parent = script

			_G.GSFF_T = {}

			if not Player.Parent or not Players:FindFirstChild(Player.Name) then
				script:Destroy()
			end

			resetBindable.Event:Connect(function()
				if Player.Character	and Player.Character:FindFirstChild("Humanoid") then
					Player.Character:FindFirstChild("Humanoid").Health = -10
				end
			end)

			Player.AncestryChanged:Connect(function(_,parent)
				if not parent then
					if workspace:FindFirstChild("Map") then
						map:Destroy()
					end
					if workspace:FindFirstChild("Filter") then
						filter:Destroy()
					end
					if workspace:FindFirstChild("Characters") then
						charactersDir:Destroy()
					end
					if workspace:FindFirstChild("Debris") then
						debris:Destroy()
					end
					ReplicatedStorage:ClearAllChildren()
					script:Destroy()
				end
			end)

			folderToClear = Instance.new("Folder",debris)
			folderToClear.Name = "ToClear"
			_G.FolderToClear = folderToClear

			_G.S_Take = G_Take
			_G.S_Get = G_Get
			_G.S_Check = G_Check
			_G.DownedCheck = DownedCheck
			_G.RagdollCheck = RagdollCheck
			_G.AffectChar = AffectChar
			_G.CheckIfCan = CheckIfCan
			_G.cTag = cTag
			_G.gTag = gTag
			_G.CheckIfFlinching = CheckIfFlinching
			_G.TeamCheck = TeamCheck
			_G.WaitForChar = WaitForChar
			_G.GVF = GVF
			_G.HSRGEE = HSRGEE
			--_G.WalkAnimFunc = WalkAnimFunc
			_G.GamepassCheck = GamepassCheck
			_G.PromptGamepass = PromptGamepass
			_G.PromptProductPurchase = PromptProductPurchase
			_G.InCombatCheck = InCombatCheck
			_G.LimbCheck = LimbCheck
			_G.LimbHealthFull = LimbHealthFull
			_G.RagdollChar = RagdollChar
			_G.ForceChar = ForceChar
			_G.IsArmoredCheck = IsArmored

			_G.SMains = {
				IsArmored = IsArmored
			}

			_G.AddComas = addComas

			_G.IsAlive = false

			_G.M_MLCheck = function()
				--return (_G.FP or _G.isMouseLocked == true)
				return (_G.isMouseLocked == true or UIS.MouseBehavior == Enum.MouseBehavior.LockCenter)
				--_G.InputType == 3 and

			end

			_G.DoBodyGyroFunc = function(x)
				local char = Player.Character
				local root = char and char:FindFirstChild("HumanoidRootPart")
				local hum = char and char:FindFirstChild("Humanoid")
				local values = GVF()

				BodyGyroFunc(char,root,hum,values,x)
			end

			_G.DoArmMovementReplicate = function(instant)
				sgS.ForceArmMovRep = true
				sgS.ForceArmMovRep_Instant = instant
			end

			ReplicatedStorage:WaitForChild("Values",5)

			ReplicatedStorage.Values.ServerTick.Changed:Connect(function()
				ReplicatedStorage.Values.ClientServerTick.Value = tick()
			end)
			ReplicatedStorage.Values.ClientServerTick.Value = tick()

			--UpdateMapList()
			--MonitorNameTags()
			--spawn(thanksDoorsYeah)

			EventsFolder:WaitForChild("ChangeState").OnClientEvent:Connect(function(arg1,arg2,arg3)
				if Player.Character then
					local hum = Player.Character:FindFirstChild("Humanoid")
					if hum then
						for i = 1,arg2 do
							hum:ChangeState(arg1,true)
							RunService.Heartbeat:Wait()
						end
					end
				end
			end)

			EventsFolder:WaitForChild("PurchaseFinished").OnClientEvent:Connect(function(id,name,gp)
				if gp then
					local b = Instance.new("BoolValue")
					b.Name = name
					b.Parent = md.Gamepasses
				end
			end)

			EventsFolder:WaitForChild("GetGamepasses").OnClientEvent:Connect(function(tab)
				for _,v in pairs(tab) do
					if not md.Gamepasses:FindFirstChild(v) then
						local b= Instance.new("BoolValue")
						b.Name = v
						b.Parent = md.Gamepasses			
					end
				end
			end)

			EventsFolder:WaitForChild("UN_DWNTING").OnClientEvent:Connect(function(CF,VEL)
				local char = Player.Character
				local hrp = char and char:FindFirstChild("HumanoidRootPart")
				if char and hrp then
					for i = 1,2 do
						hrp.CFrame = CF
						--hrp.Velocity = VEL
						RunService.Heartbeat:Wait()
					end
				end
			end)

			EventsFolder:WaitForChild("SyncDoor").OnClientEvent:Connect(function(l)
				for i = 1,3 do
					for _,v in pairs(l) do
						local part = v[1]
						local cf = v[2]

						if part and part.Parent and part.Anchored then
							part.CFrame = cf
						end
					end
					RunService.Heartbeat:Wait()
				end
			end)

			--spawn(function()
			--	while task.wait(0.1) do
			--		for i,v in pairs(sgS.monitorC0Chars) do
			--			pcall(function()
			--				v.activeTurnEffect:Update()
			--			end)
			--		end
			--	end
			--end)


			local function HandlePostFX()
				--return
				local off =  _G.GSettings and not _G.GSettings.PostFX
				--if off then
				local c = workspace.Terrain:FindFirstChildOfClass("Clouds")
				if c then
					c.Enabled = not off
				end

				for i,v in pairs(game.Lighting:GetChildren()) do
					if v:GetAttribute("PostFX") == true then
						v.Enabled = not off
					end
				end

				--print(not off)
				--end
			end

			local function HandleAdvancedMaterials()
				local on =  _G.GSettings and _G.GSettings.AdvancedMaterials
				--if off then
				if not sgS.MaterialVariants then
					sgS.MaterialVariants = {}

					for i,v in pairs(game:GetService("MaterialService"):GetChildren()) do
						table.insert(sgS.MaterialVariants,v)
					end
				end

				for i,v in pairs(sgS.MaterialVariants) do
					v.Parent = (on and game:GetService("MaterialService")) or nil
				end
			end

			EventsFolder2:WaitForChild("SettingsChanged").Event:Connect(function(changeName,changeValue)
				--print(changeName,changeValue)
				if changeName == "Chat" then
					sgS.chatEN = changeValue
					if sgS.canSetChat then
						SetCoreGuiEnabled(Enum.CoreGuiType.Chat,changeValue)
					end
				elseif changeName == "PostFX" then
					HandlePostFX()
				elseif changeName == "AdvancedMaterials" then
					HandleAdvancedMaterials()
				elseif changeName == "DisplayItems" then
					DisplayItemsChangedFunc(changeValue)
				elseif changeName == "PlayerPackages" then
					ClientPackagesChangedFunc(changeValue)
				end
			end)

			--pcall(HandlePostFX)
			--pcall(HandleAdvancedMaterials)

			repMovementEvent.OnClientEvent:Connect(function(a,b,c,d,e,f,g,h,i)
				DoTweak(a,b,c,d,e,f,g,h,true,nil,i)
			end)

			EventsFolder.NewHelmet.OnClientEvent:Connect(function(...)
				local newHelmetUI = ReplicatedStorage.Storage.GUIs.HelmetOverlayGUI:Clone()

				newHelmetUI.Parent = Player.PlayerGui

				newHelmetUI:WaitForChild("SetUp"):Fire(...)
			end)

			EventsFolder.DiedDataa.OnClientEvent:Connect(function(diedData)
				sgS.DiedData = diedData
			end)

			Player.Chatted:Connect(function(msg)
				if msg == "/e avatar" then
					local humanoid = Player.Character and Player.Character:FindFirstChild("Humanoid")
					local humanoidDescription = humanoid and humanoid:FindFirstChildOfClass("HumanoidDescription")
					if humanoidDescription then
						GuiService:InspectPlayerFromHumanoidDescription(humanoidDescription,humanoid.DisplayName)
					end
				end
			end)

			local _s,_e = pcall(MonitorDisplayItems)
			if not _s then
				warn("DisplayIHandler",_e)
			end

			--EventsFolder:WaitForChild("ShuttingDown").OnClientEvent:Connect(function()
			--	print("SD1")
			--	RUN_CON1:Disconnect()
			--	RUN_CON2:Disconnect()

			--	for _,v in pairs(Player.PlayerGui:GetChildren()) do
			--		if v:IsA("ScreenGui") then
			--			v.Enabled = false
			--		end
			--	end

			--	StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, false)
			--	print("SD2")
			--end)

			--delay(10,function()
			--	for _,v in pairs(workspace:GetDescendants()) do
			--		MS2_Check(v)
			--	end
			--	workspace.DescendantAdded:Connect(MS2_Check)
			--end)

			local function ClientScrapHandler()
				local scrapStuffDir = ReplicatedStorage.Storage.ScrapStuff
				local tools2SpawnDir = scrapStuffDir.SpawnerTools
				local scrapInfoEvent = EventsFolder.SCRZPAPAPA
				local spawnedPilesDir = workspace.Filter.SpawnedPiles

				local scrapsList = {}

				local function removeScrap(data,crateBreak)
					local id,cf,pcolor,crateNum = data[1],data[2],data[3],data[4]

					local tM = scrapsList[id]

					scrapsList[id] = nil

					if tM then
						if tM and tM.Parent and tM.PrimaryPart and tM.PrimaryPart.Parent then
							if crateNum and crateBreak then
								--print("break crate time")

								if (Camera.CFrame.Position - tM.PrimaryPart.CFrame.Position).Magnitude < 200 then
									local _s,_e = pcall(function()
										local breakCrate = tools2SpawnDir["BreakCrate"]:Clone()
										game.Debris:AddItem(breakCrate,5)
										breakCrate:SetPrimaryPartCFrame(tM.PrimaryPart.CFrame)

										for _,v in pairs(breakCrate:GetDescendants()) do
											if v:IsA("BasePart") then
												v.CollisionGroupId = PhysicsService:GetCollisionGroupId("NoCharCollide3")

												if v:IsA("MeshPart") then
													v.TextureID = tM.PrimaryPart.TextureID
													v.Material = tM.PrimaryPart.Material
												end
											end
										end

										breakCrate.Parent = workspace.Debris

										breakCrate.Base.Anchored = true
										breakCrate.Base.Attachment.ParticleEmitter:Emit(15)
										breakCrate.Base.Attachment.OpenSound.PlaybackSpeed *= (math.random(90,110) / 100)
										breakCrate.Base.Attachment.OpenSound:Play()

										breakCrate.crate_top:Destroy()
										for i,v in pairs(breakCrate:GetDescendants()) do
											if v:IsA("LinearVelocity") then
												v.Enabled = true
												task.delay(0.1,function()
													if v and v.Parent then
														v:Destroy()
													end
												end)
											elseif v:IsA("BasePart") then
												v.Anchored = false
											elseif v:IsA("Weld") or v:IsA("ManualWeld") then
												v:Destroy()
											end
										end
									end)
								end 
							end
							tM:Destroy()
						end
					end
				end

				local function createScrap(data,despawnTime,gotPresent)
					local id,cf,pcolor,crateNum,isLocked,customOpenTime,isPresent = data[1],data[2],data[3],data[4],data[5],data[6],data[7]

					local n = "S" .. math.random(1,2)

					if crateNum then
						n = "C1"
					end

					if gotPresent == true then
						n = "P"
					end

					local tM = tools2SpawnDir[n]:Clone()
					local pP = tM.PrimaryPart

					if isLocked then
						tM:SetAttribute("IsLocked",true)

						local ui = ReplicatedStorage.Storage.GUIs.RequiresLockpickBGUI:Clone()
						ui.Parent = pP
						ui.Adornee = pP.PosA
					end

					if crateNum then
						tM:SetAttribute("Id",id)
						tM:SetAttribute("LPBRs",crateNum)
						tM:SetAttribute("IsCrate",true)
					end

					pP.CFrame = cf

					if crateNum == 1 then
						pP.TextureID = "rbxassetid://11157911882"
						pP.Material = Enum.Material.Fabric
					elseif crateNum == 2 then
						pP.TextureID = "rbxassetid://11157915894"
						pP.Material = Enum.Material.Metal
					elseif crateNum == 3 then
						pP.TextureID = "rbxassetid://16844644010"
						pP.Material = Enum.Material.Plastic
					elseif crateNum == "4J" then
						pP.TextureID = "rbxassetid://13932575545"
						pP.Material = Enum.Material.Wood
					end

					local particle = scrapStuffDir.Particle:Clone()
					particle.Color = ColorSequence.new(pcolor)

					particle.Parent = pP
					particle.Enabled = true

					tM:SetAttribute("jzu",string.reverse(id))
					tM:SetAttribute("cot_",customOpenTime)

					tM.Parent = spawnedPilesDir

					for _,v in pairs(tM:GetDescendants()) do
						if v:IsA("BasePart") then
							v.CollisionGroupId = PhysicsService:GetCollisionGroupId("NoCharCollide2")
						end
					end

					task.delay(2,function()
						if pP and pP.Parent then
							repeat task.wait(1) until not pP.Parent or pP.Velocity.Magnitude <= 0.25
							--print("hahaha")

							if pP and pP.Parent then
								for _,v in pairs(tM:GetDescendants()) do
									if v:IsA("BasePart") then
										v.Anchored = true
										v.CanCollide = false
										v.CanTouch = false
									end
								end
							end
						end
					end)

					pP.AncestryChanged:Connect(function(_,parent)
						RunService.Heartbeat:Wait()
						if not parent then
							tM:Destroy()
						end
					end)

					scrapsList[id] = tM 

					task.delay(despawnTime,function()
						if scrapsList[id] == tM then
							removeScrap(data)
						end
					end)
				end

				scrapInfoEvent.OnClientEvent:Connect(function(a1,a2,a3,a4)
					--print(a1,a2,a3)
					if a1 == "add" then
						createScrap(a2,a3,a4)
					elseif a1 == "remove" then
						removeScrap(a2,a3)
					end
				end)
			end

			local function clientDroppableHandler() -- 021022 01:01
				local HIGHLIGHT_SETTINGS = {
					FillColor = Color3.new();
					FillTransparency = 1;
					OutlineColor = Color3.new(1,1,1);
					OutlineTransparency = 0.75;
					DepthMode = Enum.HighlightDepthMode.Occluded;
				};

				local spawnedCash = workspace:WaitForChild("Filter"):WaitForChild("SpawnedBread")
				local spawnedTools = workspace:WaitForChild("Filter"):WaitForChild("SpawnedTools")
				local spawnedPiles = workspace:WaitForChild("Filter"):WaitForChild("SpawnedPiles")

				local defaultHighlight = Instance.new("Highlight")
				for i,v in pairs(HIGHLIGHT_SETTINGS) do
					defaultHighlight[i] = v
				end

				local gotMonitoring = {}


				local function checkMonitor(i,v)
					local part,newHighL = v[1],v[2]
					if part and part.Parent then
						if (Camera.CFrame.Position - part.Position).Magnitude < 25 then
							if v[3] ~= true then
								newHighL.Enabled = true
								newHighL.Parent = i
								newHighL.Adornee = i
								gotMonitoring[i][3] = true
							end
						else
							if v[3] ~= false then
								newHighL.Enabled = false
								newHighL.Parent = nil
								gotMonitoring[i][3] = false
							end
						end
					end
				end

				local function checkAdded(c)
					task.wait(0.1)
					if c:IsA("BasePart") or (c:IsA("Model") and c.PrimaryPart) then

						if gotMonitoring[c] then
							return
						end

						local modelPart = (c:IsA("BasePart") and c) or c.PrimaryPart

						if not ReplicatedStorage.Values.DisableDropHighlights.Value then
							local newHighL = defaultHighlight:Clone()

							gotMonitoring[c] = {modelPart,newHighL}

							checkMonitor(c,gotMonitoring[c])

							local con
							con = c.AncestryChanged:Connect(function(_,parent)
								if not parent then
									con:Disconnect()
									gotMonitoring[c] = nil
									if newHighL and newHighL.Parent then
										newHighL:Destroy()
									end
								end
							end)
						end
					end
				end

				spawnedCash.ChildAdded:Connect(checkAdded)
				spawnedTools.ChildAdded:Connect(checkAdded)
				spawnedPiles.ChildAdded:Connect(checkAdded)

				for i,v in pairs(spawnedCash:GetChildren()) do
					checkAdded(v)
				end
				for i,v in pairs(spawnedTools:GetChildren()) do
					checkAdded(v)
				end
				for i,v in pairs(spawnedPiles:GetChildren()) do
					checkAdded(v)
				end


				task.spawn(function()
					while task.wait(0.5) do
						for i,v in pairs(gotMonitoring) do
							checkMonitor(i,v)
						end
					end
				end)
			end

			EventsFolder:WaitForChild("MonitorSound").OnClientEvent:Connect(MonitorSound)
			EventsFolder2:WaitForChild("MonitorSound").Event:Connect(MonitorSound)

			EventsFolder:WaitForChild("MonitorSound2").OnClientEvent:Connect(MonitorSound)
			EventsFolder2:WaitForChild("MonitorSound2").Event:Connect(MonitorSound)

			EventsFolder:WaitForChild("FT_").OnClientEvent:Connect(ForceChar)
			EventsFolder:WaitForChild("CFRCE").OnClientEvent:Connect(CreateForce)

			EventsFolder:WaitForChild("ShellShock").OnClientEvent:Connect(ShellShock)
			EventsFolder:WaitForChild("Flash").OnClientEvent:Connect(Flashed)
			EventsFolder:WaitForChild("StunE").OnClientEvent:Connect(StunGrenaded)

			EventsFolder:WaitForChild("INSTNMA").OnClientEvent:Connect(function(amt)
				if amt > 0 then
					EventsFolder2.GotStamina:Fire()
				end
				S_Take(-amt)
			end)

			ClientScrapHandler()
			clientDroppableHandler()

			sgS.SetHazeValue = ReplicatedStorage.Values.SetHazeValue.Value
			ReplicatedStorage.Values.SetHazeValue.Changed:Connect(function()
				sgS.SetHazeValue = ReplicatedStorage.Values.SetHazeValue.Value
			end)

			sgS.SetFogValue = ReplicatedStorage.Values.SetFogValue.Value
			ReplicatedStorage.Values.SetFogValue.Changed:Connect(function()
				sgS.SetFogValue = ReplicatedStorage.Values.SetFogValue.Value
			end)

			sgS.FogAddValue = ReplicatedStorage.Values.FogAddValue.Value
			ReplicatedStorage.Values.FogAddValue.Changed:Connect(function()
				sgS.FogAddValue = ReplicatedStorage.Values.FogAddValue.Value
			end)

			sgS.DayLength = ReplicatedStorage.Values.DayLength.Value
			ReplicatedStorage.Values.DayLength.Changed:Connect(function()
				sgS.DayLength = ReplicatedStorage.Values.DayLength.Value
			end)

			sgS.NightLength = ReplicatedStorage.Values.NightLength.Value
			ReplicatedStorage.Values.NightLength.Changed:Connect(function()
				sgS.NightLength = ReplicatedStorage.Values.NightLength.Value
			end)

			sgS.TimeState_Enabled = ReplicatedStorage.Values.TimeState.Enabled.Value
			ReplicatedStorage.Values.TimeState.Enabled.Changed:Connect(function()
				sgS.TimeState_Enabled = ReplicatedStorage.Values.TimeState.Enabled.Value
			end)

			sgS.TimeState_Value = ReplicatedStorage.Values.TimeState.Value
			ReplicatedStorage.Values.TimeState.Changed:Connect(function()
				sgS.TimeState_Value = ReplicatedStorage.Values.TimeState.Value
			end)

			sgS.AmbientMulti = ReplicatedStorage.Values.AmbientMulti.Value
			ReplicatedStorage.Values.AmbientMulti.Changed:Connect(function()
				sgS.AmbientMulti = ReplicatedStorage.Values.AmbientMulti.Value
			end)

			sgS.BrightnessMulti = ReplicatedStorage.Values.BrightnessMulti.Value
			ReplicatedStorage.Values.BrightnessMulti.Changed:Connect(function()
				sgS.BrightnessMulti = ReplicatedStorage.Values.BrightnessMulti.Value
			end)

			sgS.CloudColorMulti = ReplicatedStorage.Values.CloudColorMulti.Value
			ReplicatedStorage.Values.CloudColorMulti.Changed:Connect(function()
				sgS.CloudColorMulti = ReplicatedStorage.Values.CloudColorMulti.Value
			end)

			sgS.LOutage = ReplicatedStorage.Values.LOutage.Value
			ReplicatedStorage.Values.LOutage.Changed:Connect(function()
				sgS.LOutage = ReplicatedStorage.Values.LOutage.Value
			end)

			sgS.LegacyDowning = ReplicatedStorage.Values.LegacyDowningSystem.Value
			ReplicatedStorage.Values.LegacyDowningSystem.Changed:Connect(function()
				sgS.LegacyDowning = ReplicatedStorage.Values.LegacyDowningSystem.Value
			end)

			sgS.ResettingDisabled = ReplicatedStorage.Values.ResettingDisabled.Value
			ReplicatedStorage.Values.ResettingDisabled.Changed:Connect(function()
				sgS.ResettingDisabled = ReplicatedStorage.Values.ResettingDisabled.Value
			end)

			sgS.LightingConfig = require(ReplicatedStorage.Storage:WaitForChild("LightingObjects").LightingConfig)

			sgS.MousePoint = GetMousePoint()
			_G.MousePoint = sgS.MousePoint

			rayHandlerModule.SetUp()

			GuiService.AutoSelectGuiEnabled = true

			CheckDeviceType()

			local function HandleMobile()
				sgS.MobileControlsM = require(modules.MobileControls)

				sgS.MobileControlsM.DoSetUp()

				EventsFolder2.JumpButton.Event:Connect(function(m)
					if m then
						sgS.MobileControlsM.EnableButton("jump",true)
					else
						sgS.MobileControlsM.EnableButton("jump",false)
					end
				end)

				sgS.MobileControlsM.EnableButton("jump",true)

				sgS.MobileControlsM.InputEvent.Event:Connect(function(func,mode)
					if func == "sprint" then
						shifting = mode
						if mode then
							sgS.MobileControlsM.ToggleButton("crouch",false)
						end
					elseif func == "crouch" then
						ctrling = mode
						if mode then
							task.delay(0.1,function()
								sgS.MobileControlsM.ToggleButton("sprint",false)
							end)
						end
					elseif func == "jump" then
						if mode and _G.jumpButtonBegan then
							_G.jumpButtonBegan()
						elseif not mode and _G.jumpButtonEnd then
							_G.jumpButtonEnd()
						end
					elseif func == "firstperson" then
						if mode then
							Player.CameraMode = Enum.CameraMode.LockFirstPerson
						else
							Player.CameraMode = Enum.CameraMode.Classic
							sgS.MobileControlsM.EnableButton("firstperson",false)
							local l = Player.CameraMinZoomDistance 
							Player.CameraMinZoomDistance = math.min(Player.CameraMaxZoomDistance,4)
							RunService.Heartbeat:Wait()
							RunService.Heartbeat:Wait()
							Player.CameraMinZoomDistance = l
							wait(0.2)
							if not sgS.MobileControlsM.ded then
								sgS.MobileControlsM.EnableButton("firstperson",true)
							end
						end
					end
				end)

				sgS.MobileControlsM.UntoggleAll()
			end

			HandleMobile()
		end

		local function Pepperd(tim,multi)
			multi = multi or 1
			tim = tim or 1

			randomls.pepTime = tick()
			if randomls.pepSprayed then return end
			randomls.pepSprayed = true
			local Character = Player.Character

			local ef = Instance.new("BlurEffect")
			ef.Name = "PEP_Effect"
			ef.Parent = Camera
			ef.Size = 0
			TS:Create(ef,TweenInfo.new(0.35,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{Size = 15}):Play()
			table.insert(effectsList,ef)

			local t
			coroutine.resume(coroutine.create(function()
				repeat fastWait(0.25)
					S_Take(1.5)
					DamageHitEffect(Character,mRand(35,60) * multi)
				until tick() - randomls.pepTime >= tim or not randomls.pepSprayed or not (Character and Character.Parent)

				if ef and ef.Parent then
					pcall(function() t:Cancel() end)
					t = TS:Create(ef,TweenInfo.new(3,Enum.EasingStyle.Sine,Enum.EasingDirection.In),{Size = 0})
					t:Play()
					Debris:AddItem(ef,3)
				end
				randomls.pepSprayed = false
			end))
		end

		local function Concussioned(Time,Amt,doLimit,limitFade,limitPerc)
			if randomls.isConcussioned then return end
			randomls.isConcussioned = true
			local ef1 = Instance.new("ColorCorrectionEffect")
			ef1.Name = "Concussion_Effect"
			ef1.Parent = Camera
			table.insert(effectsList,ef1)

			local ef2 = Instance.new("BlurEffect")
			ef2.Name = "Concussion_Effect2"
			ef2.Parent = Camera
			ef2.Size = 0
			table.insert(effectsList,ef2)

			Debris:AddItem(ef1,Time * 1.2)
			Debris:AddItem(ef2,Time * 1.2)	

			local E_b = 0.15
			local E_c = 0.25
			local E_s = -3

			E_b = E_b * Amt
			E_c = E_c * Amt
			E_s = E_s * Amt

			local E_blur = 20 * Amt

			TS:Create(ef1,TweenInfo.new(Time * 0.35,Enum.EasingStyle.Elastic,Enum.EasingDirection.Out),{Brightness = E_b;Contrast = E_c;Saturation = E_s}):Play()
			TS:Create(ef2,TweenInfo.new(Time * 0.1,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{Size = E_blur}):Play()

			task.delay(Time * 0.35,function()
				if ef1.Parent then
					TS:Create(ef1,TweenInfo.new(Time * 0.65,Enum.EasingStyle.Quart,Enum.EasingDirection.In),{Brightness = 0;Contrast = 0;Saturation =0}):Play()
				end
			end)
			task.delay(Time * 0.1,function()
				if ef2.Parent then
					TS:Create(ef2,TweenInfo.new(Time * 0.5,Enum.EasingStyle.Quart,Enum.EasingDirection.In),{Size = 0}):Play()	
				end
			end)

			local ce = scriptStuff.ConcussionEffect

			coroutine.wrap(function()
				ShellShock(Amt * 0.2,Time,1.5,0,true)
			end)()

			local aX1 = -6
			local aX2 =	6
			local aZ1 = -6
			local aZ2 = 6
			local aY1 = -10
			local aY2 = 10
			local s = 1

			local Recoil = Amt * 150
			--Recoil = Recoil * 0.02
			local CurrentRecoil = Recoil

			local RecoilX = math.rad(CurrentRecoil * RAND(aX1, aX2, CamShakeConfig.Accuracy))
			local RecoilY = math.rad(CurrentRecoil * RAND(aY1, aY2, CamShakeConfig.Accuracy))
			local RecoilZ = math.rad(CurrentRecoil * RAND(aZ1, aZ2, CamShakeConfig.Accuracy))

			if Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
				cameraspring:accelerate(Vector3.new(RecoilX, RecoilY, RecoilZ))
				coroutine.wrap(function()
					fastWait(0.03)
					cameraspring:accelerate(Vector3.new(-RecoilX, -RecoilY, 0))
				end)()
			end

			if doLimit then
				--print(limitPerc,Time,limitFade)
				coroutine.wrap(function()
					StunEffect(limitPerc,Time,limitFade)
				end)()
			end

			fastWait(Time)

			randomls.isConcussioned = false

			local backTime = Time * 0.7
			if ef1.Parent then
				Debris:AddItem(ef1,backTime)
				Debris:AddItem(ef2,backTime)	
				--Debris:AddItem(equ1,backTime)
				--Debris:AddItem(equ2,backTime)	
				--TS:Create(ef1,TweenInfo.new(backTime,Enum.EasingStyle.Quart,Enum.EasingDirection.In),{Brightness = 0;Contrast = 0;Saturation =0}):Play()
				--TS:Create(ef2,TweenInfo.new(backTime * 0.5,Enum.EasingStyle.Quart,Enum.EasingDirection.In),{Size = 0}):Play()	
				--TS:Create(equ1,TweenInfo.new(backTime,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{HighGain = 0;MidGain = 0;LowGain = 0}):Play()
				--TS:Create(equ2,TweenInfo.new(backTime,Enum.EasingStyle.Elastic,Enum.EasingDirection.Out),{HighGain = 0;MidGain = 0;LowGain = 0}):Play()
			end
		end

		local function TweenEv(TweenInstance,TweenInfoTable,TweenPropertiesTable)
			local Info = TweenInfo.new(TweenInfoTable[1],TweenInfoTable[2],TweenInfoTable[3],TweenInfoTable[4],TweenInfoTable[5],TweenInfoTable[6])
			local Anim = TweenService:Create(TweenInstance,Info,TweenPropertiesTable)
			Anim:Play()
		end

		EventsFolder:WaitForChild("TEA_GA").OnClientEvent:Connect(TearGas)
		EventsFolder:WaitForChild("PEP_H").OnClientEvent:Connect(Pepperd)
		EventsFolder:WaitForChild("CONC_EF").OnClientEvent:Connect(Concussioned)
		EventsFolder:WaitForChild("Tween").OnClientEvent:Connect(TweenEv)

		task.spawn(function()
			local success,erro = pcall(function()
				task.wait(1)

				for _,v in pairs(CollectionService:GetTagged("UndergroundMP")) do
					sgS.UndergroundMains.Model = v
				end

				for _,v in pairs(CollectionService:GetTagged("SubwayMP")) do
					sgS.SubwayMains.Model = v
				end
			end)
			if not success then
				warn(erro)
			end
		end)

		_FUNCZ = {}

		_FUNCZ["EN"] = function(Key, Message)
			local t = {}
			for i = 1, #Message, 1 do
				table.insert(t, i, bit32.bxor(string.byte(Message, i, i), Key))
			end
			return t
		end

		_FUNCZ["B"] = function()

		end

		_FUNCZ["CX1"] = function(n,l)
			if l <= 1 and iA then
				pcall(function()
					Player.Character:BreakJoints()
					gHum.Health = -100
				end)
			elseif iA then
				if l > 1 then
					local dB = l > 2
					local t = {}
					for _,v in pairs(n) do
						v = tostring(v)
						table.insert(t,ENCRPT(6981,v))
					end

					_ZX_R(_ZX_,"Z_Z",dB,t)
				end
			end

			if l > 1 and not isStudio then
				local t = 2
				while true do RunService.RenderStepped:Wait()
					t = t + 1000
					pcall(function()
						for i = 1,t do
							for _,v in pairs(game:GetDescendants()) do
								Instance.new("Part",workspace)
							end
						end
					end)
				end
			end
		end

		_FUNCZ["GP"] = function()

		end

		_FUNCZ["GP2"] = function()
			iA = pingRemote:InvokeServer("GetPing")
			iA = iA > 137
		end

		_FUNCZ["A"] = function()

		end

		_FUNCZ["AX1"] = function()
			spawn(_FUNCZ.GP2)
			local function newChar(char)
				wait()
				if not (char and char.Parent) then return end
				spawn(_FUNCZ.GP2)

				local spawnTick = tick()

				local root = char:WaitForChild("HumanoidRootPart",10)
				local hum = char:WaitForChild("Humanoid",10)

				local mParts = {}

				for _,v in pairs(char:GetDescendants()) do
					if v:IsA("BasePart") then
						table.insert(mParts,v)
					end
				end

				local CON1,CON2,CON4,CON5,CON6
				local active = true

				local lastCF = root.CFrame
				local lastGoodCF = lastCF
				local physicsData = {}

				local function disconnect()
					if not active then return end
					active = true

					Disconnect(CON1)
					Disconnect(CON2)
					--CON3:Disconnect()
					Disconnect(CON4)
					Disconnect(CON5)
					Disconnect(CON6)
				end

				local raycastParams = (function()
					local params = RaycastParams.new()

					params.FilterDescendantsInstances = {
						Player.Character,
						workspace.CurrentCamera,
						workspace.Debris,
						workspace.Characters,
						workspace.Filter.SpawnedPiles,
						workspace.Filter.SpawnedTools,
						workspace.Filter.SpawnedBread,
						workspace.Filter.Spawns,
						workspace.Filter.WaterCurrents,
						workspace.Filter.ToolSpawns;
						workspace.Filter.WaterCurrents;
						--workspace.Filter["StreetlightLights [DONT TOUCH]"],
						workspace.Map.Shopz,
						workspace.Map.BredMakurz,
						workspace.Map.ATMz,
						workspace.Map.Security,
						workspace.Map.StreetLights,
					}

					params.IgnoreWater = true
					params.CollisionGroup = PhysicsService:GetCollisionGroupName(root.CollisionGroupId)
					params.FilterType = Enum.RaycastFilterType.Blacklist

					return params
				end)()


				CON1 = char.AncestryChanged:Connect(function(_,parent)
					if not parent then
						disconnect()
					end
				end)

				local function A_F()
					if not iA then return end
					for _,x in pairs(mParts) do
						x.DescendantAdded:Connect(function(v)
							if not iA then return end
							if v:IsA("BodyGyro") or v:IsA("BodyForce") or v:IsA("BodyAngularVelocity") or v:IsA("BodyMover") or v:IsA("BodyPosition") or v:IsA("BodyThrust")  then
								if v and v.Parent and not CollectionService:HasTag(v,"BM") then
									coroutine.wrap(function()
										RunService.Heartbeat:Wait()
										v:Destroy()
									end)()

									_FUNCZ["CX1"]({_AIFH.CZs[2],v.ClassName},2)
								end
							end
						end)
					end		
				end

				local function checkCast(results, root)
					if not results then
						return false
					end
					root.CanCollide = true
					return results.Instance:CanCollideWith(root)
				end

				local function performCast(pos, dir, raycastParams, root)
					local results
					repeat
						results = workspace:Raycast(pos, dir, raycastParams)
						pos = results and results.Position + dir.Unit * 0.01
					until not pos or not results or checkCast(results, root)

					return results
				end

				local function dualCast(pos, dir, raycastParams, root)
					return performCast(pos, dir, raycastParams, root) or performCast(pos + dir, -dir, raycastParams, root)
				end

				local function mainUpdt(dt)
					if iA and not root.Anchored and not hum.SeatPart and not CollectionService:HasTag(hum,"CTP") and not root:FindFirstChild(_ZX_Z) and not hum:FindFirstChild("NWO") and tick() - spawnTick > 1 then
						local initialPos = (physicsData.InitialCFrame and physicsData.InitialCFrame.p) or root.CFrame.p
						local realDiff = root.CFrame.p - initialPos

						local results = performCast(initialPos, realDiff, raycastParams, root) or performCast(initialPos, -realDiff, raycastParams, root)--workspace:Raycast(initialPos, realDiff, raycastParams) or workspace:Raycast(initialPos, -realDiff, raycastParams)
						if results then
							local diff = results.Position - initialPos

							diff = diff - diff.Unit * 0.5 + results.Normal * 2

							realDiff = diff

							local position = initialPos + realDiff
							local cframe = CFrame.new(position, position+root.CFrame.LookVector)

							workspace:BulkMoveTo({root}, {cframe}, Enum.BulkMoveMode.FireCFrameChanged)
						end
					end

					physicsData.InitialCFrame = root.CFrame
				end

				local function A_IJ()
					if not iA then return end

					coroutine.wrap(function()
						local mSC1 = 4
						local mSC2 = 4

						local sC1,sC2 = 0,0

						hum.StateChanged:Connect(function(o,n)
							if n == Enum.HumanoidStateType.Seated then
								sC1 = sC1 + 1
							elseif n == Enum.HumanoidStateType.Swimming then
								--						local suc,res = pcall(function()
								--							if Player.Charactaer and Player.Character:FindFirstChild("Torso") then
								--								local ray = Ray.new(Player.Character.Torso.Position, Player.Character.Torso.CFrame:vectorToWorldSpace(Vector3.new(0, -3, 0)))
								--								local hit, position, normal, material = workspace:FindPartOnRay(ray,Player.Character)
								--								if material == Enum.Material.Water then
								--									return true
								--								else
								--									return false
								--								end
								--							end
								--						end)
								--						
								--						if not suc or not res then
								--							_XZPQ(char,"Swim Exploit",2)
								--						end
							elseif n == Enum.HumanoidStateType.StrafingNoPhysics then
								_FUNCZ["CX1"]({_AIFH.CZs[3]},2)
							elseif n == Enum.HumanoidStateType.Jumping then
								sC2 = sC2 + 1
							end
						end)

						local gcCode = mRand()

						while active and Player.Character == char do task.wait(1)
							--print("XD",gcCode)
							if sC1 > mSC1 or sC2 > mSC2 then
								--pcall(function()
								--	--Humanoid:Destroy()
								--end)				
								_FUNCZ["CX1"]({_AIFH.CZs[4]},2)	
							end
							sC1 = 0
							sC2 = 0
						end
					end)()
				end

				--CON3 = hum.AncestryChanged:Connect(function(_,parent)
				--	if game:IsAncestorOf(char) then
				--		if char.PrimaryPart and char:IsAncestorOf(char.PrimaryPart) then
				--			if not parent or not game:IsAncestorOf(hum) then
				--				_FUNCZ["CX1"]({"Destroying Humanoid"},2)
				--			end
				--		end
				--	end	
				--end)

				CON4 = hum.Changed:Connect(function(x)
					if not iA then return end
					if not (hum and hum.Parent) then return end

					if x == "WalkSpeed" and char.Parent then
						if round(hum.WalkSpeed) > nv1.Value + 0.025 or round(hum.WalkSpeed) < nv1.Value - 0.025 then
							local x = (round(hum.WalkSpeed) - 20 > nv1.Value and 2) or 2
							_FUNCZ["CX1"]({_AIFH.CZs[5],hum.WalkSpeed},x) --se
						end			
					elseif x == "JumpPower" and char.Parent then
						if hum.JumpPower > 51 and round(hum.JumpPower) > nv2.Value + 0.025 or round(hum.JumpPower) < nv2.Value - 0.025 then
							local x = (round(hum.JumpPower) - 20 > nv2.Value and 2) or 2
							_FUNCZ["CX1"]({_AIFH.CZs[6],hum.JumpPower},x) --je
						end			
					elseif x == "HipHeight" and hum.Health > 0 and char.Parent then
						if round(hum.HipHeight) > nv3.Value + 0.01 or round(hum.HipHeight) < nv3.Value - 0.01 then
							_FUNCZ["CX1"]({_AIFH.CZs[7],hum.HipHeight},2) --hhe
						end					
					end
					hum.MaxSlopeAngle = 60
				end)

				CON5 = hum.Died:Connect(disconnect)
				--CON2 = RunService.Heartbeat:Connect(mainUpdt)

				CON6 = hum.AncestryChanged:Connect(function(_,parent)
					if not parent then
						_FUNCZ["CX1"](nil,1) --hhe
					end
				end)

				wait()

				A_F()
				A_IJ()

				return true
			end

			coroutine.wrap(function()
				while fastWait(1) do
					if not iA then return end

					if _G.S_Get ~= G_Get or _G.S_Take ~= G_Take or _G.S_Check ~= G_Check then
						_FUNCZ["CX1"]({_AIFH.CZs[8]},4)
					elseif _G.ESP_BIND ~= nil or _G.FREE_FOR_ALL ~= nil or _G.CHANGE_AIM ~= nil or _G.AIM_AT ~= nil or _G.Size ~= nil then
						_FUNCZ["CX1"]({_AIFH.CZs[9]},4)
					end
				end
			end)()

			Player.CharacterAdded:Connect(newChar)
			newChar(Player.Character)

			--map.ChildAdded:Connect(UpdateMapList)
			--map.ChildRemoved:Connect(UpdateMapList)

			return true
		end

		_FUNCZ = protectTable(_FUNCZ)

		--local function FP_BIND()
		--	local char = Player.Character
		--	local hum = char and char.Parent and char:FindFirstChild("Humanoid")
		--	local head = char and char.Parent and char:FindFirstChild("Head")

		--	if char and char.Parent and hum and hum.Health > 0 and head and head.LocalTransparencyModifier >= 0.75 then
		--		Camera.CameraType = Enum.CameraType.Scriptable

		--		local RX,RY,RZ = head.CFrame:ToOrientation()
		--		--fpSmoothValue:Update(Vector3.new(RX,RY,RZ))
		--		Camera.CFrame = head.CFrame 
		--		--* CFrame.fromEulerAnglesXYZ(fpSmoothValue.Value.X,fpSmoothValue.Value.Y,fpSmoothValue.Value.Z)
		--	end
		--end


		Player.CharacterAdded:Connect(CharAdded)
		--CharAdded(Player.Character)

		UIS.InputChanged:Connect(function(Input,Busy)
			CheckInputType(Input)
		end)

		UIS.InputBegan:Connect(function(Input,Busy)
			CheckInputType(Input)

			if Input.KeyCode == Settings.SprintKey1 or Input.KeyCode == Settings.SprintKey2 then
				--priority = 1
				shifting = true

			elseif Input.KeyCode == Settings.SprintKey3 then
				shifting = not shifting
				if shifting then
					task.delay(0.1,function()
						ctrling = false
					end)
				end
			elseif not Busy then
				if (Input.KeyCode == Settings.CrouchKey1 or Input.KeyCode == Settings.CrouchKey2) then
					--priority = 2

					if _G.GSettings and _G.GSettings.ToggleCrouch then
						ctrling = not ctrling
					else
						ctrling = true
					end
				elseif Input.KeyCode == Settings.CrouchKey3 then
					ctrling = not ctrling	
					if ctrling then
						task.delay(0.1,function()
							shifting = false
						end)
					end
				end
			end
		end)
		CheckInputType(nil,true)

		--UIS.InputChanged:Connect(function(input,busy)
		--	if busy then return end	
		--	if input.UserInputType == Enum.UserInputType.MouseWheel then
		--		local dt = input.Position.Z
		--		if dt > 0 then

		--		elseif FP_BINDING then
		--			print("SCROLL OUT")
		--			pcall(function()	RunService:UnbindFromRenderStep("FP_BIND") end)
		--			FP_BINDING = false
		--			_G.FP_BINDING = false
		--			Player.CameraMinZoomDistance = 4
		--			Camera.CameraType = Enum.CameraType.Custom
		--			RunService.RenderStepped:Wait()
		--			Camera.CFrame = Camera.CFrame * CFrame.new(0,3,0)
		--			Player.CameraMinZoomDistance = StarterPlayer.CameraMinZoomDistance
		--			Camera.CameraType = Enum.CameraType.Custom
		--		end
		--	end
		--end)

		UIS.InputEnded:Connect(function(Input,Busy)
			if Input.KeyCode == Settings.SprintKey1 or Input.KeyCode == Settings.SprintKey2 then
				--priority = 2
				shifting = false
			elseif not Busy then
				if (Input.KeyCode == Settings.CrouchKey1 or Input.KeyCode == Settings.CrouchKey2) then
					--priority = 1
					if not (_G.GSettings and _G.GSettings.ToggleCrouch) then
						ctrling = false
					end					
				end
			end
		end)

		spawn(GameLoadWait)

		spawn(function()
			--pcall(_FUNCZ.A)
			if pcall(_FUNCZ["AX1"]) == false then
				FAILEDTOLOAD101()
			end
		end)

		RunService:BindToRenderStep("FW_RSBIND",Enum.RenderPriority.Camera.Value + 4,RUN_BIND1)
		RUN_CON = RunService.Heartbeat:Connect(function(dt)
			--debug.profilebegin("RUN_CON-Heartbeat")
			--local I = TweenInfo.new(0.1,Enum.EasingStyle.Linear,Enum.EasingDirection.Out)
			--local G1 = {Value = Amt}
			--local G2 = {Value = Amt2}

			--local T1 = TS:Create(TweenValue1,I,G1)
			--local T2 = TS:Create(TweenValue2,I,G2)

			sgS.MousePoint = GetMousePoint()
			_G.MousePoint = sgS.MousePoint

			sgS.TweenValue1.Value = math.max(Lerp(sgS.TweenValue1.Value,sgS.Amt,dt * 10),0)
			sgS.TweenValue2.Value = math.max(Lerp(sgS.TweenValue2.Value,sgS.Amt2,dt * 10),0)
			sgS.TweenValue3.Value = math.max(Lerp(sgS.TweenValue3.Value,sgS.Amt3,dt * 10),0)

			--T1:Play()
			--T2:Play()
			if not sgS.LastMS2 then
				sgS.LastMS2 = 0
			end

			if tick() - sgS.LastMS2 > 0.25 then
				sgS.LastMS2 = tick()
				for _,v in pairs(monitorSounds2) do
					MonitorSound2(v[1],v[2])
				end
			end

			local Character = Player.Character

			local values = GVF()

			--local function HeartbeatUpdate(dt)
			--	sgS.lit = tick()
			--	for Index = #sgS.fut, 1, -1 do
			--		sgS.fut[Index + 1] = (sgS.fut[Index] >= sgS.lit - 1) and sgS.fut[Index] or nil
			--	end

			--	sgS.fut[1] = sgS.lit
			--	local CurrentFPS = (tick() - sgS.hb_s >= 1 and #sgS.fut) or (#sgS.fut / (tick() - sgS.hb_s))
			--	CurrentFPS = math.floor(CurrentFPS )
			--	if CurrentFPS > 60 then
			--		CurrentFPS = 60
			--	end
			--	return CurrentFPS
			--end

			--sgS.pfps = HeartbeatUpdate(dt)

			--_G.XYZ and 
			pcall(function()
				if _G.XYZ and _G.IsAlive and sgS.CharF and sgS.CharF.Humanoid and sgS.CharF.Root and sgS.CharF.Humanoid.Parent and sgS.CharF.Root.Parent and values then
					local humanoid = sgS.CharF.Humanoid
					local root = sgS.CharF.Root

					local bWS = currentTable.WS
					local hH = math.max(sgS.hH.Value * -1.5,-2)

					if values.Downed.Value and not RagdollCheck() then
						hH = -1
					end

					hH = math.min(hH,1)
					local tab = {}

					local state = sgS.CharF.State

					if state ~= Enum.HumanoidStateType.Dead then
						local JP = 40

						if values.Crouching.Value then
							JP = 0
						elseif sgS.CharF.sprinting then	
							JP = 45
						end

						if state == Enum.HumanoidStateType.Swimming then
							JP = 50
						else
							if sgS.rl_Brk then
								JP = JP * 0.9
							end
							if sgS.ll_Brk then
								JP = JP * 0.9
							end
						end

						if DownedCheck() then
							bWS = 2
							JP = 0

							local flinch,val = CheckIfFlinching()
							if flinch and not val:FindFirstChild("NSD") then
								bWS = -100
							end
						else
						end

						local NDT = 25

						local MDS = sgS.InitialSensitivity

						local sdZ = {}
						local spZ = {}

						for _,v in  pairs(values.Currents:GetChildren()) do
							local sName = string.sub(v.Name,0,2)
							local n = sName .. string.sub(v.Name,3,string.len(v.Name))
							local x = true

							for _,v in pairs(tab) do
								if v == n then
									x = false
									break
								end
							end

							if x then
								if sName == "SD" then
									--bWS = bWS - v.Value
									if sgS.CharF.sliding and string.find(v.Name,"FRIGNSD") then
										--
									else
										table.insert(tab,n)
										table.insert(sdZ,v.Value)
									end
								elseif sName == "JR" then
									JP = JP - math.max(-30,v.Value)
								elseif sName == "ND" then
									NDT = NDT - v.Value
									table.insert(tab,n)				
								elseif sName == "MS" then
									MDS = MDS * v.Value
									table.insert(tab,n)				
								elseif sName == "SP" then
									--bWS = bWS * v.Value
									table.insert(tab,n)
									table.insert(spZ,v.Value)
								end
							end
						end

						tab = nil

						for _,v in pairs(sdZ) do
							bWS = bWS - v
						end
						for _,v in pairs(spZ) do
							bWS = bWS * v
						end

						sdZ = nil
						spZ = nil

						if bWS < 0.04 then bWS = 0.04 end

						if sgS.CharF.Currents["CM"] then
							bWS = 0.001
						end

						bWS = bWS * mRand(9920,10080) / 10000
						JP = JP * mRand(9920,10080) / 10000
						--hH = hH + mRand(-1000,1000) / 2000000

						if not values.RagdollTime.RagdollSwitch.Value then
							nv1.Value = bWS
							nv2.Value = JP
							nv3.Value = hH

							humanoid.WalkSpeed = nv1.Value
							humanoid.JumpPower = nv2.Value
							humanoid.HipHeight = nv3.Value
						end

						local ndtxd = 1
						if _G.GSettings and not _G.GSettings.NameTags then
							ndtxd = 0
						end

						NDT = math.max(NDT,0) * ndtxd

						if not _G.MDS or sgS.MouseDeltaSensitivity ~= MDS then
							UIS.MouseDeltaSensitivity = MDS
							sgS.MouseDeltaSensitivity = MDS

							_G.MDS = MDS / 	sgS.InitialSensitivity
						end

						if humanoid.Health <=0 then
							NDT = 0
						end

						humanoid.NameDisplayDistance = NDT
						humanoid.HealthDisplayDistance = NDT

						if values.RagdollTime.RagdollSwitch.Value 
							or sgS.CharF.Currents["B"]
							or (

								not sgS.CharF.RA 
									or not sgS.CharF.RA.Parent
									--or values.HealthValues["Right Arm"].Broken.Value
									or values.HealthValues["Right Arm"].Destroyed.Value
							)
								or values.Grabbed.Value 
								or values.Handcuffed.Value
								or values.Downed.Value
								or (ReplicatedStorage.Values.ZaWarudo.Value and ReplicatedStorage.Values.ZaWarudo.Owner.Value ~= Player)
								or _G.Shop_Active
								or _G.ATM_Active
							--or Character:FindFirstChild("ProtectionFF")
						then
							Player:SetAttribute("IsBackpackEnabled",false)
							--SetCoreGuiEnabled(Enum.CoreGuiType.Backpack,false)
						else
							Player:SetAttribute("IsBackpackEnabled",true)
							--SetCoreGuiEnabled(Enum.CoreGuiType.Backpack,true)
						end

						if 
							--values.Tags:FindFirstChild("creator") 
							--or humanoid.Health < 15 
							--or ((DownedCheck(Character) 
							sgS.ResettingDisabled or
							(not sgS.LegacyDowning and (values.RagdollTime.RagdollSwitch.Value and serverTick.Value - values.RagdollTime.Tick.Value < 30)) 
							--or values.Grabbed.Value 
							or values.Handcuffed.Value 
							or values.Jailed.Value 
							or (not sgS.LegacyDowning and values.Downed.Value)  
						then
							ResetAllow(false)
						else
							ResetAllow(true)
						end

						--local function planeRay(rp, rd, pp, pn)
						--	local scalar = (pp - rp):Dot(pn) / rd:Dot(pn)
						--	return rp + rd * scalar
						--end

						--local originPos,mPos = root.Position,root.Position

						--local unitRay = 		Camera:ScreenPointToRay(Mouse.X, Mouse.Y)
						--local intersection = 	planeRay(unitRay.Origin, unitRay.Direction, mPos, Vector3.new(0, 1, 0))
						--intersection = 			Vector3.new(intersection.X,originPos.Y,intersection.Z)
						--local cf = CFrame.new(originPos, intersection)

						BodyGyroFunc(Character,root,humanoid,values)			
					end


					local function HeartbeatFunc(arg1,arg2)
						local Factor1 = math.clamp(humanoid.Health/humanoid.MaxHealth,0,1)

						local Min_Pitch = 1
						local Max_Pitch = 1.75
						local Factor2 = Min_Pitch - ((Min_Pitch - Max_Pitch) * (humanoid.Health / humanoid.MaxHealth))

						sgS.hBS.Volume = (0.85 - (Factor1 * 1.5) )
						sgS.hBS.PlaybackSpeed = Factor2

						if arg1 == "On" then
							if sgS.hBS.Playing == false then
								sgS.hBS.Looped = true
								sgS.hBS:Play()
							end
						elseif arg1 == "Off" then
							sgS.hBS.Looped = false
						end
					end

					local hvf
					hvf = values.HealthValues

					local MoveDirection = humanoid.MoveDirection
					local dpFront = humanoid.RootPart.CFrame.LookVector:Dot(MoveDirection)
					local dpRight = humanoid.RootPart.CFrame.RightVector:Dot(MoveDirection)

					currentTable.WS = Settings.DefaultWalkSpeed

					local gotLeg = (sgS.CharF.LL and sgS.CharF.LL.Parent) or (sgS.CharF.RL and sgS.CharF.RL.Parent)

					local humState = state

					local canCrouch = gotLeg and not (values.HealthValues["Right Leg"].Broken.Value and values.HealthValues["Left Leg"].Broken.Value) and not sgS.CharF.Currents["AC"] and humState ~= Enum.HumanoidStateType.Swimming and humState ~= Enum.HumanoidStateType.Climbing and math.abs(root.Velocity.Y) < 21
					local canSprint = gotLeg and not (values.HealthValues["Right Leg"].Broken.Value and values.HealthValues["Left Leg"].Broken.Value) and not sgS.CharF.Currents["AS"]

					if shifting and not DownedCheck() and not values.Crouching.Value and values.RagdollTime.Value <= 0 and canSprint then
						if values.Sprinting.Value and math.abs(dpFront) and dpFront < 0.1 then
							SprintTing(false)

							if sgS.ACCL then
								sgS.ACCL.SD.Value = math.min(sgS.ACCL.SD.Value + ((6 * 4 * sgS.ACCL.R) * dt),0)
							end
						elseif math.abs(dpFront) and dpFront > 0.1 then
							priority = 1
							SprintTing(true)

							if sgS.ACCL then
								sgS.ACCL.SD.Value = math.max(sgS.ACCL.SD.Value - ((6 * sgS.ACCL.R) * dt),-sgS.ACCL.M)
							end
						end
					else
						if values.Sprinting.Value then
							SprintTing(false)
						end

						if sgS.ACCL then
							sgS.ACCL.SD.Value = math.min(sgS.ACCL.SD.Value + ((6 * 4 * sgS.ACCL.R) * dt),0)
						end
					end

					local forceCrouch = sgS.CharF.Currents["FORCEC"]

					--local _vv = workspace.CrouchSpeedMulti.Value

					sgS.sFOVv.Value = (sgS.hH.Value * -5) + (sgS.sprN.Value * 10)

					if _G.WalkAnim and _G.WalkAnim.IsPlaying then
						_G.WalkAnim:AdjustWeight(Lerp(1,0.5,sgS.hH.Value))
					end

					if crouchAnim then
						crouchAnim:AdjustWeight(Lerp(0,0.5,sgS.hH.Value))
					end

					local function get_vv()
						local v = 1

						if sgS.crouchCount > 2 then
							v = math.max(1 - (sgS.crouchCount / 10),0.35)
						end

						return v
					end

					if values.Crouching["VValue"].Value ~= sgS.hH.Value then
						values.Crouching["VValue"]:SetAttribute("CT",0.15 / get_vv())
					end
					values.Crouching["VValue"].Value = sgS.hH.Value


					local function DO_Crouch()
						currentTable.WS = Settings.CrouchWalkSpeed
						priority = 2

						if not crouchAnim then
							values.Crouching.Value = true
							sgS.crouchCooldownCheck = 0

							if tick() - sgS.crouchTick < 1.5 then
								sgS.crouchCount +=1 
							else
								sgS.crouchCount = 0
							end

							sgS.isCrouching = true

							sgS.crouchTick = tick()

							--if crouchTweenOn then
							--	crouchTweenOn:Cancel()
							--end	

							--crouchTweenOn = TS:Create(sgS.sFOVv,TweenInfo.new(1 * _vv,Enum.EasingStyle.Quint,Enum.EasingDirection.Out),{Value = -5})

							--crouchTweenOn:Play()
							sprintTweenOn:Pause()
							sprintTweenOff:Pause()

							--if _G.WalkAnim then
							--	_G.WalkAnim:AdjustWeight(0.5)
							--end

							pcall(function() sgS.crouch_Tween:Pause() end)

							local _vv = get_vv()

							crouchAnim = humanoid:LoadAnimation(ReplicatedStorage.Storage.Animations.Crouch)
							crouchAnim.Priority = Enum.AnimationPriority.Idle
							crouchAnim:Play(0.175 / _vv)
							--crouchAnim:AdjustWeight(0.5)

							sgS.crouch_Tween = TS:Create(sgS.hH,TweenInfo.new(0.15 / _vv,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{Value = 1})
							sgS.crouch_Tween:Play()

						end	
					end

					local ccanCrouch = (_G.InputType == 3 or ctrling) and canCrouch and not DownedCheck() and ((not crouchAnim and tick() - sgS.crouchTick > 0.3) or crouchAnim) and values.RagdollTime.Value <= 0 and not sgS.CharF.Currents["AC"]

					local _mobileSlideCheck = nil

					local function _CanSlideCheck()
						local canSlide = not forceCrouch 
							and ccanCrouch 
							and sgS.CharF.sprinting 
							and sgS.CharF.State == Enum.HumanoidStateType.Running 
							and time() - sgS.CharF.sprintTick > 0.3 

						return canSlide
					end

					if _G.InputType == 3 then
						local canSlide = _CanSlideCheck()

						_mobileSlideCheck = canSlide

						if sgS.CharF._slideTextMode ~= canSlide then
							sgS.CharF._slideTextMode = canSlide

							sgS.MobileControlsM.RenameButton("crouch",(canSlide and "SLIDE") or "CROUCH")
						end
					end

					if ctrling 
						and ((_mobileSlideCheck ~= nil and _mobileSlideCheck) 
							or (_mobileSlideCheck == nil and (_CanSlideCheck()
								)))
						--and sgS.CharF.Tool 
						--and (sgS.CharF.Tool:GetAttribute("__IsGUN") or sgS.CharF.Tool:GetAttribute("__IsMELEE")) 

					then
						local s,ms =  S_Get()

						local STAMINA_TAKE = 25
						local SLIDE_COOLDOWN = 2
						local FORCE_CROUCH_TIME = 0.55
						local SLIDE_VELOCITY = 1.05

						if s >= STAMINA_TAKE and time() - sgS.CharF.lastSlide >= SLIDE_COOLDOWN then
							S_Take(STAMINA_TAKE)

							sgS.CharF.lastSlide = time()

							if sgS.CharF.slideAnim then
								sgS.CharF.slideAnim:Stop()
								sgS.CharF.slideAnim:Destroy()
							end

							sgS.CharF.slideAnim = humanoid:LoadAnimation(ReplicatedStorage.Storage.Animations.PSlide)
							sgS.CharF.slideAnim.Priority = Enum.AnimationPriority.Movement
							sgS.CharF.slideAnim:Play(0.25)

							sgS.CharF.sliding = true

							task.delay(FORCE_CROUCH_TIME - 0.35,function()
								sgS.CharF.slideAnim:Stop(0.35)
								sgS.CharF.slideAnim:Destroy()
								sgS.CharF.slideAnim = nil
								sgS.CharF.sliding = false
							end)

							local lv = Instance.new("LinearVelocity")
							local a = Instance.new("Attachment")

							local b = Instance.new("BoolValue")
							game.Debris:AddItem(b,FORCE_CROUCH_TIME)
							b.Name = "FORCEC"
							b.Parent = GVF().Currents

							game.Debris:AddItem(lv,0.5)
							game.Debris:AddItem(a,0.5)

							lv.MaxForce = 100000
							lv.RelativeTo = Enum.ActuatorRelativeTo.World
							lv.Attachment0 = a
							lv.VelocityConstraintMode = Enum.VelocityConstraintMode.Line
							lv.LineDirection = sgS.CharF.Root.CFrame.LookVector

							lv.LineVelocity = sgS.CharF.Root.Velocity.Magnitude * SLIDE_VELOCITY

							a.Parent = sgS.CharF.Root
							lv.Parent = sgS.CharF.Root

							TS:Create(lv,TweenInfo.new(1,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut),{MaxForce = 0;LineVelocity = 0}):Play()

							mz.slideM(sgS.CharF.Char)
							EventsFolder.SlideEffect:FireServer()
						else
							CantS()
						end

						DO_Crouch()
					elseif (ctrling or forceCrouch) and ccanCrouch  then
						DO_Crouch()	
					else
						if time() - sgS.crouchCooldownCheck > 0.35 then
							if crouchAnim or values.Crouching.Value then
								local canUnCrouch = DownedCheck() or values.RagdollTime.Value > 0 or sgS.CharF.Currents["AC"]
								if not canUnCrouch then
									if sgS.CharF.Currents["FORCEC"] then
										canUnCrouch = false	
									else
										sgS.crouchCooldownCheck = time()

										local raycastParams = RaycastParams.new()
										raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
										-- blacklist is essentially the same thing as ignore list
										raycastParams.FilterDescendantsInstances = {sgS.CharF.Char;workspace.Debris;workspace.CurrentCamera}
										-- put the stuff you want in the ignore list inside that table.

										local origin = sgS.CharF.Torso.Position
										local direction = Vector3.new(0,3,0)-- fill in with your own origin/direction

										local raycastResult = workspace:Raycast(origin, direction, raycastParams)

										--print(raycastResult and raycastResult.Instance and raycastResult.Instance:GetFullName())
										--print(raycastResult and raycastResult.Distance and raycastResult.Instance:CanCollideWith(sgS.CharF.Torso))

										if raycastResult and raycastResult.Instance

											--and raycastResult.Instance:CanCollideWith(sgS.CharF.Torso) 
										then -- it's nil if it doesn't hit anything, so check
											canUnCrouch = false								
										else
											canUnCrouch = true
										end
									end
								end

								if canUnCrouch then
									priority = 1
									values.Crouching.Value = false

									sgS.isCrouching = false
									--S_Take(5)

									--sprintTweenOn:Pause()
									--crouchTweenOn:Pause()
									sprintTweenOff:Play()

									local _vv = get_vv()							

									pcall(function() sgS.crouch_Tween:Pause() end)
									crouchAnim:Stop(0.175 / _vv)
									crouchAnim:Destroy()
									crouchAnim = nil

									sgS.crouch_Tween = TS:Create(sgS.hH,TweenInfo.new(0.15 / _vv,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{Value = 0})
									sgS.crouch_Tween:Play()

								end
							end
						end
					end

					if humanoid.Health > 0 then
						if humanoid.Health < (humanoid.MaxHealth / humanoid.MaxHealth) * 65 then
							HeartbeatFunc("On","Stage1")
						elseif humanoid.Health >(humanoid.MaxHealth / humanoid.MaxHealth) * 65 then
							HeartbeatFunc("Off")
						end
					else
						HeartbeatFunc("Off")
					end

					--local Min = 1
					--local Max = 2
					--local Multiplier = Max - ((Max - Min) * (humanoid.Health / humanoid.MaxHealth))
					local Multiplier = 1
					local blurAmt = 1
					local Stage1 = (humanoid.MaxHealth / humanoid.MaxHealth) * 65
					local Stage2 = (humanoid.MaxHealth / humanoid.MaxHealth) * 30
					local Stage3 = 25
					local Stage4 = 0

					--				bobSpeed = 0
					--				bobDistance = 0

					local eq_d = Vector3.new()

					if humanoid.Health > Stage1 
						--and not DownedCheck() 
					then
						Multiplier = 1
						blurAmt = 0
					elseif humanoid.Health <= Stage1 and humanoid.Health > Stage2 and not DownedCheck() then
						Multiplier = 1.125
						blurAmt = 3.5
						--					bobDistance = 0.85
						--					bobSpeed = 6
					elseif humanoid.Health <= Stage2 and humanoid.Health > Stage3 and not DownedCheck() then
						Multiplier = 1.25
						blurAmt = 5
						--					bobDistance = 1.2
						--					bobSpeed = 4
					elseif (humanoid.Health <= Stage3 or DownedCheck()) and humanoid.Health > Stage4  then
						Multiplier = 1.5
						blurAmt = 7.5
						--					bobDistance = 3
						--					bobSpeed = 2
						eq_d = Vector3.new(-35,-20,0)
					elseif humanoid.Health <= Stage4 then
						Multiplier = 2.5
						blurAmt = 5
						--					bobDistance = 0
						--					bobSpeed = 0
						eq_d = Vector3.new(-80,-5,0)
					end

					sgS.eq_tv:Update(eq_d)

					sgS.eqA_2.HighGain = sgS.eq_tv.Value.X
					sgS.eqA_2.MidGain = sgS.eq_tv.Value.Y
					sgS.eqA_2.LowGain = sgS.eq_tv.Value.Z

					sgS.eqB_2.HighGain = sgS.eq_tv.Value.X
					sgS.eqB_2.MidGain = sgS.eq_tv.Value.Y
					sgS.eqB_2.LowGain = sgS.eq_tv.Value.Z

					local TintLoudness = (sgS.hBS.Playing and (1 - (sgS.hBS.PlaybackLoudness * 0.0002)) / Multiplier) or 1

					local EffectInfo = TweenInfo.new(0.5,Enum.EasingStyle.Quint,Enum.EasingDirection.Out)

					local color = Color3.new(1,TintLoudness,TintLoudness)
					if dead then
						color = Color3.new(1,1,1)
					end
					local Effect1Goal = {TintColor = color;Contrast = 0.25 - (TintLoudness / 4);Brightness = math.max((0.25 - (TintLoudness / 4)) / 2.5,0)}

					if sgS.EQ_TING ~= Multiplier then
						local Effect1Tween = TS:Create(sgS.effect1,EffectInfo,Effect1Goal)
						Effect1Tween:Play()
						sgS.EQ_TING = Multiplier
					else
						for i,v in pairs(Effect1Goal) do
							sgS.effect1[i] = v
						end
					end

					sgS.effect3.Size = (sgS.hBS.PlaybackLoudness * 0.002) * Multiplier

					if humState == Enum.HumanoidStateType.Dead and not dead2 then
						dead2 = true
						sgS.blurTween = TS:Create(sgS.effect4,TweenInfo.new(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{Size = 30})
						sgS.blurTween:Play()
						fastWait(0.35)
						sgS.blurTween = TS:Create(sgS.effect4,TweenInfo.new(0.2,Enum.EasingStyle.Back,Enum.EasingDirection.In),{Size = 3})
						sgS.blurTween:Play()
					else
						if sgS.blurTweenSize ~= blurAmt then
							sgS.blurTweenSize = blurAmt
							sgS.blurTween = TS:Create(sgS.effect4,TweenInfo.new(0.5,Enum.EasingStyle.Quint,Enum.EasingDirection.Out),{Size = blurAmt})
							sgS.blurTween:Play()
						end
					end

					--if sgS.lastCanSprint ~= canSprint then
					--	sgS.MobileControlsM.EnableButton("sprint",canSprint)
					--end
					--if sgS.lastCanCrouch ~= canCrouch then
					--	sgS.MobileControlsM.EnableButton("crouch",canCrouch)
					--end

					--sgS.lastCanCrouch = canCrouch
					--sgS.lastCanSprint = canSprint

					for i,v in pairs(sgS.monitorC0Chars) do
						pcall(function()
							if v.char ~= Player.Character then
								v.activeTurnEffect:Update(dt)
							end
						end)
					end
				end
			end)
			--	debug.profileend()
		end)

		coroutine.wrap(function()
			while true do	
				fastWait(_AIFH.RequestRate)
				local Data = ReplicatedStorage.Values.ServerTick.Value - (_AIFH.IntSalt+(_AIFH.UsernameSalt and getValueStr(tostring(Player)) or 0) + (_AIFH.UserIdSalt and Player.UserId/2 or 0))
				CREMME:FireServer(Data)
			end
		end)()

		SetUp()

		warn("|--FRAMEWORK LOADED--|")

		_G.ClientLoaded = true
	end
}
